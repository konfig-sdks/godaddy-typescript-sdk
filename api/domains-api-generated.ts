/* tslint:disable */
/* eslint-disable */
/*


All the help and tools you need to grow online: Websites, Domains, Digital and Social Marketing - plus GoDaddy Guides with you every step of the way.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ConsentRedemption } from '../models';
// @ts-ignore
import { ConsentRenew } from '../models';
// @ts-ignore
import { ConsentV2 } from '../models';
// @ts-ignore
import { DomainContactsCreateV2 } from '../models';
// @ts-ignore
import { DomainDetailV2 } from '../models';
// @ts-ignore
import { DomainForwarding } from '../models';
// @ts-ignore
import { DomainForwardingCreate } from '../models';
// @ts-ignore
import { DomainForwardingMask } from '../models';
// @ts-ignore
import { DomainPurchaseV2 } from '../models';
// @ts-ignore
import { DomainRedeemV2 } from '../models';
// @ts-ignore
import { DomainRenewV2 } from '../models';
// @ts-ignore
import { DomainTransferAuthCode } from '../models';
// @ts-ignore
import { DomainTransferInV2 } from '../models';
// @ts-ignore
import { ErrorLimit } from '../models';
// @ts-ignore
import { JsonSchema } from '../models';
// @ts-ignore
import { Maintenance } from '../models';
// @ts-ignore
import { MaintenanceDetail } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * DomainsApi - axios parameter creator
 * @export
 */
export const DomainsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accepts the transfer in
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} domain Domain to accept the transfer in for
         * @param {DomainTransferAuthCode} domainTransferAuthCode An Authorization code for transferring the Domain
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTransferIn: async (customerId: string, domain: string, domainTransferAuthCode: DomainTransferAuthCode, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('acceptTransferIn', 'customerId', customerId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('acceptTransferIn', 'domain', domain)
            // verify required parameter 'domainTransferAuthCode' is not null or undefined
            assertParamExists('acceptTransferIn', 'domainTransferAuthCode', domainTransferAuthCode)
            const localVarPath = `/v2/customers/{customerId}/domains/{domain}/transferInAccept`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainTransferAuthCode,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/{domain}/transferInAccept',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainTransferAuthCode, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept transfer out
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} domain Domain to accept the transfer out for
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTransferOut: async (customerId: string, domain: string, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('acceptTransferOut', 'customerId', customerId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('acceptTransferOut', 'domain', domain)
            const localVarPath = `/v2/customers/{customerId}/domains/{domain}/transferOutAccept`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/{domain}/transferOutAccept',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
         * @summary Submit a forwarding cancellation request for the given fqdn
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} fqdn The fully qualified domain name whose forwarding details are to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelForwardingRequest: async (customerId: string, fqdn: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('cancelForwardingRequest', 'customerId', customerId)
            // verify required parameter 'fqdn' is not null or undefined
            assertParamExists('cancelForwardingRequest', 'fqdn', fqdn)
            const localVarPath = `/v2/customers/{customerId}/domains/forwards/{fqdn}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"fqdn"}}`, encodeURIComponent(String(fqdn !== undefined ? fqdn : `-fqdn-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/forwards/{fqdn}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels the transfer in
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} domain Domain to cancel the transfer in for
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferIn: async (customerId: string, domain: string, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('cancelTransferIn', 'customerId', customerId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('cancelTransferIn', 'domain', domain)
            const localVarPath = `/v2/customers/{customerId}/domains/{domain}/transferInCancel`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/{domain}/transferInCancel',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
         * @summary Create a new forwarding configuration for the given FQDN
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your own customer id.
         * @param {string} fqdn The fully qualified domain name whose forwarding details are to be modified.
         * @param {DomainForwardingCreate} domainForwardingCreate Domain forwarding rule to create for the specified fqdn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForwardingConfiguration: async (customerId: string, fqdn: string, domainForwardingCreate: DomainForwardingCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('createForwardingConfiguration', 'customerId', customerId)
            // verify required parameter 'fqdn' is not null or undefined
            assertParamExists('createForwardingConfiguration', 'fqdn', fqdn)
            // verify required parameter 'domainForwardingCreate' is not null or undefined
            assertParamExists('createForwardingConfiguration', 'domainForwardingCreate', domainForwardingCreate)
            const localVarPath = `/v2/customers/{customerId}/domains/forwards/{fqdn}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"fqdn"}}`, encodeURIComponent(String(fqdn !== undefined ? fqdn : `-fqdn-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainForwardingCreate,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/forwards/{fqdn}',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainForwardingCreate, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve details for the specified Domain
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} domain Domain name whose details are to be retrieved
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {Array<'actions' | 'contacts' | 'dnssecRecords' | 'registryStatusCodes'>} [includes] Optional details to be included in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails: async (customerId: string, domain: string, xRequestId?: string, includes?: Array<'actions' | 'contacts' | 'dnssecRecords' | 'registryStatusCodes'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getDetails', 'customerId', customerId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getDetails', 'domain', domain)
            const localVarPath = `/v2/customers/{customerId}/domains/{domain}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (includes) {
                localVarQueryParameter['includes'] = includes.join(COLLECTION_FORMATS.csv);
            }

            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/{domain}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
         * @summary Retrieve the forwarding information for the given fqdn
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} fqdn The fully qualified domain name whose forwarding details are to be retrieved.
         * @param {boolean} [includeSubs] Optionally include all sub domains if the fqdn specified is a domain and not a sub domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForwardingInfo: async (customerId: string, fqdn: string, includeSubs?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getForwardingInfo', 'customerId', customerId)
            // verify required parameter 'fqdn' is not null or undefined
            assertParamExists('getForwardingInfo', 'fqdn', fqdn)
            const localVarPath = `/v2/customers/{customerId}/domains/forwards/{fqdn}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"fqdn"}}`, encodeURIComponent(String(fqdn !== undefined ? fqdn : `-fqdn-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (includeSubs !== undefined) {
                localVarQueryParameter['includeSubs'] = includeSubs;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/forwards/{fqdn}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the schema to be submitted when registering a Domain for the specified TLD
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} tld The Top-Level Domain whose schema should be retrieved
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisterSchema: async (customerId: string, tld: string, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getRegisterSchema', 'customerId', customerId)
            // verify required parameter 'tld' is not null or undefined
            assertParamExists('getRegisterSchema', 'tld', tld)
            const localVarPath = `/v2/customers/{customerId}/domains/register/schema/{tld}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"tld"}}`, encodeURIComponent(String(tld !== undefined ? tld : `-tld-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/register/schema/{tld}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the details for an upcoming system Maintenances
         * @param {string} maintenanceId The identifier for the system maintenance
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingMaintenanceDetails: async (maintenanceId: string, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'maintenanceId' is not null or undefined
            assertParamExists('getUpcomingMaintenanceDetails', 'maintenanceId', maintenanceId)
            const localVarPath = `/v2/domains/maintenances/{maintenanceId}`
                .replace(`{${"maintenanceId"}}`, encodeURIComponent(String(maintenanceId !== undefined ? maintenanceId : `-maintenanceId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/domains/maintenances/{maintenanceId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of upcoming system Maintenances
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {'ACTIVE' | 'CANCELLED'} [status] Only include results with the selected &#x60;status&#x60; value.  Returns all results if omitted&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong style&#x3D;\&#39;margin-left: 12px;\&#39;&gt;ACTIVE&lt;/strong&gt; - The upcoming maintenance is active.&lt;/li&gt;&lt;li&gt;&lt;strong style&#x3D;\&#39;margin-left: 12px;\&#39;&gt;CANCELLED&lt;/strong&gt; - The upcoming maintenance has been cancelled.&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [modifiedAtAfter] Only include results with &#x60;modifiedAt&#x60; after the supplied date
         * @param {string} [startsAtAfter] Only include results with &#x60;startsAt&#x60; after the supplied date
         * @param {number} [limit] Maximum number of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingMaintenancesList: async (xRequestId?: string, status?: 'ACTIVE' | 'CANCELLED', modifiedAtAfter?: string, startsAtAfter?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/domains/maintenances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (modifiedAtAfter !== undefined) {
                localVarQueryParameter['modifiedAtAfter'] = modifiedAtAfter;
            }

            if (startsAtAfter !== undefined) {
                localVarQueryParameter['startsAtAfter'] = startsAtAfter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/domains/maintenances',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate transfer out to another registrar for a .uk domain.
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} domain Domain to initiate the transfer out for
         * @param {string} registrar Registrar tag to push transfer to
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateTransferOut: async (customerId: string, domain: string, registrar: string, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('initiateTransferOut', 'customerId', customerId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('initiateTransferOut', 'domain', domain)
            // verify required parameter 'registrar' is not null or undefined
            assertParamExists('initiateTransferOut', 'registrar', registrar)
            const localVarPath = `/v2/customers/{customerId}/domains/{domain}/transferOut`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (registrar !== undefined) {
                localVarQueryParameter['registrar'] = registrar;
            }

            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/{domain}/transferOut',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
         * @summary Modify the forwarding information for the given fqdn
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} fqdn The fully qualified domain name whose forwarding details are to be modified.
         * @param {DomainForwardingCreate} domainForwardingCreate Domain forwarding rule to create or replace on the fqdn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyForwardingInfo: async (customerId: string, fqdn: string, domainForwardingCreate: DomainForwardingCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('modifyForwardingInfo', 'customerId', customerId)
            // verify required parameter 'fqdn' is not null or undefined
            assertParamExists('modifyForwardingInfo', 'fqdn', fqdn)
            // verify required parameter 'domainForwardingCreate' is not null or undefined
            assertParamExists('modifyForwardingInfo', 'domainForwardingCreate', domainForwardingCreate)
            const localVarPath = `/v2/customers/{customerId}/domains/forwards/{fqdn}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"fqdn"}}`, encodeURIComponent(String(fqdn !== undefined ? fqdn : `-fqdn-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainForwardingCreate,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/forwards/{fqdn}',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainForwardingCreate, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase and register the specified Domain
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {DomainPurchaseV2} domainPurchaseV2 An instance document expected to match the JSON schema returned by &#x60;./schema/{tld}&#x60;
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseRegisterDomain: async (customerId: string, domainPurchaseV2: DomainPurchaseV2, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('purchaseRegisterDomain', 'customerId', customerId)
            // verify required parameter 'domainPurchaseV2' is not null or undefined
            assertParamExists('purchaseRegisterDomain', 'domainPurchaseV2', domainPurchaseV2)
            const localVarPath = `/v2/customers/{customerId}/domains/register`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainPurchaseV2,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/register',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainPurchaseV2, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase and start or restart transfer process
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} domain Domain to transfer in
         * @param {DomainTransferInV2} domainTransferInV2 Details for domain transfer purchase
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseTransferProcess: async (customerId: string, domain: string, domainTransferInV2: DomainTransferInV2, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('purchaseTransferProcess', 'customerId', customerId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('purchaseTransferProcess', 'domain', domain)
            // verify required parameter 'domainTransferInV2' is not null or undefined
            assertParamExists('purchaseTransferProcess', 'domainTransferInV2', domainTransferInV2)
            const localVarPath = `/v2/customers/{customerId}/domains/{domain}/transfer`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainTransferInV2,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/{domain}/transfer',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainTransferInV2, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase a restore for the given domain to bring it out of redemption
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} domain Domain to request redeem for
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {DomainRedeemV2} [domainRedeemV2] Options for redeeming existing Domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemDomainRestore: async (customerId: string, domain: string, xRequestId?: string, domainRedeemV2?: DomainRedeemV2, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('redeemDomainRestore', 'customerId', customerId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('redeemDomainRestore', 'domain', domain)
            const localVarPath = `/v2/customers/{customerId}/domains/{domain}/redeem`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainRedeemV2,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/{domain}/redeem',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainRedeemV2, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reject transfer out
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} domain Domain to reject the transfer out for
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {'EVIDENCE_OF_FRAUD' | 'URDP_ACTION' | 'COURT_ORDER' | 'DISPUTE_OVER_IDENTITY' | 'NO_PAYMENT_FOR_PREVIOUS_REGISTRATION_PERIOD' | 'WRITTEN_OBJECTION' | 'TRANSFERRED_WITHIN_SIXTY_DAYS'} [reason] Transfer out reject reason
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectTransferOut: async (customerId: string, domain: string, xRequestId?: string, reason?: 'EVIDENCE_OF_FRAUD' | 'URDP_ACTION' | 'COURT_ORDER' | 'DISPUTE_OVER_IDENTITY' | 'NO_PAYMENT_FOR_PREVIOUS_REGISTRATION_PERIOD' | 'WRITTEN_OBJECTION' | 'TRANSFERRED_WITHIN_SIXTY_DAYS', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('rejectTransferOut', 'customerId', customerId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('rejectTransferOut', 'domain', domain)
            const localVarPath = `/v2/customers/{customerId}/domains/{domain}/transferOutReject`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (reason !== undefined) {
                localVarQueryParameter['reason'] = reason;
            }

            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/{domain}/transferOutReject',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Renew the specified Domain
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} domain Domain to be renewed
         * @param {DomainRenewV2} domainRenewV2 Options for renewing existing Domain
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewDomain: async (customerId: string, domain: string, domainRenewV2: DomainRenewV2, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('renewDomain', 'customerId', customerId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('renewDomain', 'domain', domain)
            // verify required parameter 'domainRenewV2' is not null or undefined
            assertParamExists('renewDomain', 'domainRenewV2', domainRenewV2)
            const localVarPath = `/v2/customers/{customerId}/domains/{domain}/renew`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainRenewV2,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/{domain}/renew',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainRenewV2, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restarts transfer in request from the beginning
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} domain Domain to restart the transfer in
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartTransferIn: async (customerId: string, domain: string, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('restartTransferIn', 'customerId', customerId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('restartTransferIn', 'domain', domain)
            const localVarPath = `/v2/customers/{customerId}/domains/{domain}/transferInRestart`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/{domain}/transferInRestart',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retries the current transfer in request with supplied Authorization code
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} domain Domain to retry the transfer in
         * @param {DomainTransferAuthCode} domainTransferAuthCode An Authorization code for transferring the Domain
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryTransferInProcess: async (customerId: string, domain: string, domainTransferAuthCode: DomainTransferAuthCode, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('retryTransferInProcess', 'customerId', customerId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('retryTransferInProcess', 'domain', domain)
            // verify required parameter 'domainTransferAuthCode' is not null or undefined
            assertParamExists('retryTransferInProcess', 'domainTransferAuthCode', domainTransferAuthCode)
            const localVarPath = `/v2/customers/{customerId}/domains/{domain}/transferInRetry`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainTransferAuthCode,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/{domain}/transferInRetry',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainTransferAuthCode, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate the request body using the Domain Registration Schema for the specified TLD
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {DomainPurchaseV2} domainPurchaseV2 An instance document expected to match the JSON schema returned by &#x60;./schema/{tld}&#x60;
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDomainRegistration: async (customerId: string, domainPurchaseV2: DomainPurchaseV2, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('validateDomainRegistration', 'customerId', customerId)
            // verify required parameter 'domainPurchaseV2' is not null or undefined
            assertParamExists('validateDomainRegistration', 'domainPurchaseV2', domainPurchaseV2)
            const localVarPath = `/v2/customers/{customerId}/domains/register/validate`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainPurchaseV2,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/register/validate',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainPurchaseV2, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsApi - functional programming interface
 * @export
 */
export const DomainsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accepts the transfer in
         * @param {DomainsApiAcceptTransferInRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptTransferIn(requestParameters: DomainsApiAcceptTransferInRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainTransferAuthCode: DomainTransferAuthCode = {
                authCode: requestParameters.authCode
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptTransferIn(requestParameters.customerId, requestParameters.domain, domainTransferAuthCode, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Accept transfer out
         * @param {DomainsApiAcceptTransferOutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptTransferOut(requestParameters: DomainsApiAcceptTransferOutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptTransferOut(requestParameters.customerId, requestParameters.domain, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
         * @summary Submit a forwarding cancellation request for the given fqdn
         * @param {DomainsApiCancelForwardingRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelForwardingRequest(requestParameters: DomainsApiCancelForwardingRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelForwardingRequest(requestParameters.customerId, requestParameters.fqdn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancels the transfer in
         * @param {DomainsApiCancelTransferInRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransferIn(requestParameters: DomainsApiCancelTransferInRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransferIn(requestParameters.customerId, requestParameters.domain, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
         * @summary Create a new forwarding configuration for the given FQDN
         * @param {DomainsApiCreateForwardingConfigurationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createForwardingConfiguration(requestParameters: DomainsApiCreateForwardingConfigurationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainForwardingCreate: DomainForwardingCreate = {
                mask: requestParameters.mask,
                type: requestParameters.type,
                url: requestParameters.url
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createForwardingConfiguration(requestParameters.customerId, requestParameters.fqdn, domainForwardingCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve details for the specified Domain
         * @param {DomainsApiGetDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetails(requestParameters: DomainsApiGetDetailsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainDetailV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDetails(requestParameters.customerId, requestParameters.domain, requestParameters.xRequestId, requestParameters.includes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
         * @summary Retrieve the forwarding information for the given fqdn
         * @param {DomainsApiGetForwardingInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForwardingInfo(requestParameters: DomainsApiGetForwardingInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainForwarding>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForwardingInfo(requestParameters.customerId, requestParameters.fqdn, requestParameters.includeSubs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the schema to be submitted when registering a Domain for the specified TLD
         * @param {DomainsApiGetRegisterSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegisterSchema(requestParameters: DomainsApiGetRegisterSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegisterSchema(requestParameters.customerId, requestParameters.tld, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the details for an upcoming system Maintenances
         * @param {DomainsApiGetUpcomingMaintenanceDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpcomingMaintenanceDetails(requestParameters: DomainsApiGetUpcomingMaintenanceDetailsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpcomingMaintenanceDetails(requestParameters.maintenanceId, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of upcoming system Maintenances
         * @param {DomainsApiGetUpcomingMaintenancesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpcomingMaintenancesList(requestParameters: DomainsApiGetUpcomingMaintenancesListRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Maintenance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpcomingMaintenancesList(requestParameters.xRequestId, requestParameters.status, requestParameters.modifiedAtAfter, requestParameters.startsAtAfter, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Initiate transfer out to another registrar for a .uk domain.
         * @param {DomainsApiInitiateTransferOutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateTransferOut(requestParameters: DomainsApiInitiateTransferOutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateTransferOut(requestParameters.customerId, requestParameters.domain, requestParameters.registrar, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
         * @summary Modify the forwarding information for the given fqdn
         * @param {DomainsApiModifyForwardingInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyForwardingInfo(requestParameters: DomainsApiModifyForwardingInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainForwardingCreate: DomainForwardingCreate = {
                mask: requestParameters.mask,
                type: requestParameters.type,
                url: requestParameters.url
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyForwardingInfo(requestParameters.customerId, requestParameters.fqdn, domainForwardingCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purchase and register the specified Domain
         * @param {DomainsApiPurchaseRegisterDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseRegisterDomain(requestParameters: DomainsApiPurchaseRegisterDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainPurchaseV2: DomainPurchaseV2 = {
                consent: requestParameters.consent,
                contacts: requestParameters.contacts,
                domain: requestParameters.domain,
                metadata: requestParameters.metadata,
                nameServers: requestParameters.nameServers,
                period: requestParameters.period,
                privacy: requestParameters.privacy,
                renewAuto: requestParameters.renewAuto
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseRegisterDomain(requestParameters.customerId, domainPurchaseV2, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purchase and start or restart transfer process
         * @param {DomainsApiPurchaseTransferProcessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseTransferProcess(requestParameters: DomainsApiPurchaseTransferProcessRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainTransferInV2: DomainTransferInV2 = {
                authCode: requestParameters.authCode,
                consent: requestParameters.consent,
                contacts: requestParameters.contacts,
                identityDocumentId: requestParameters.identityDocumentId,
                metadata: requestParameters.metadata,
                period: requestParameters.period,
                privacy: requestParameters.privacy,
                renewAuto: requestParameters.renewAuto
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseTransferProcess(requestParameters.customerId, requestParameters.domain, domainTransferInV2, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purchase a restore for the given domain to bring it out of redemption
         * @param {DomainsApiRedeemDomainRestoreRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeemDomainRestore(requestParameters: DomainsApiRedeemDomainRestoreRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainRedeemV2: DomainRedeemV2 = {
                consent: requestParameters.consent
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeemDomainRestore(requestParameters.customerId, requestParameters.domain, requestParameters.xRequestId, domainRedeemV2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reject transfer out
         * @param {DomainsApiRejectTransferOutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectTransferOut(requestParameters: DomainsApiRejectTransferOutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectTransferOut(requestParameters.customerId, requestParameters.domain, requestParameters.xRequestId, requestParameters.reason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Renew the specified Domain
         * @param {DomainsApiRenewDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renewDomain(requestParameters: DomainsApiRenewDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainRenewV2: DomainRenewV2 = {
                consent: requestParameters.consent,
                expires: requestParameters.expires,
                period: requestParameters.period
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.renewDomain(requestParameters.customerId, requestParameters.domain, domainRenewV2, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restarts transfer in request from the beginning
         * @param {DomainsApiRestartTransferInRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartTransferIn(requestParameters: DomainsApiRestartTransferInRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartTransferIn(requestParameters.customerId, requestParameters.domain, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retries the current transfer in request with supplied Authorization code
         * @param {DomainsApiRetryTransferInProcessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryTransferInProcess(requestParameters: DomainsApiRetryTransferInProcessRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainTransferAuthCode: DomainTransferAuthCode = {
                authCode: requestParameters.authCode
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.retryTransferInProcess(requestParameters.customerId, requestParameters.domain, domainTransferAuthCode, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate the request body using the Domain Registration Schema for the specified TLD
         * @param {DomainsApiValidateDomainRegistrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateDomainRegistration(requestParameters: DomainsApiValidateDomainRegistrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainPurchaseV2: DomainPurchaseV2 = {
                consent: requestParameters.consent,
                contacts: requestParameters.contacts,
                domain: requestParameters.domain,
                metadata: requestParameters.metadata,
                nameServers: requestParameters.nameServers,
                period: requestParameters.period,
                privacy: requestParameters.privacy,
                renewAuto: requestParameters.renewAuto
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateDomainRegistration(requestParameters.customerId, domainPurchaseV2, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DomainsApi - factory interface
 * @export
 */
export const DomainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsApiFp(configuration)
    return {
        /**
         * 
         * @summary Accepts the transfer in
         * @param {DomainsApiAcceptTransferInRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTransferIn(requestParameters: DomainsApiAcceptTransferInRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.acceptTransferIn(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept transfer out
         * @param {DomainsApiAcceptTransferOutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTransferOut(requestParameters: DomainsApiAcceptTransferOutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.acceptTransferOut(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
         * @summary Submit a forwarding cancellation request for the given fqdn
         * @param {DomainsApiCancelForwardingRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelForwardingRequest(requestParameters: DomainsApiCancelForwardingRequestRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelForwardingRequest(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels the transfer in
         * @param {DomainsApiCancelTransferInRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferIn(requestParameters: DomainsApiCancelTransferInRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelTransferIn(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
         * @summary Create a new forwarding configuration for the given FQDN
         * @param {DomainsApiCreateForwardingConfigurationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForwardingConfiguration(requestParameters: DomainsApiCreateForwardingConfigurationRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createForwardingConfiguration(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve details for the specified Domain
         * @param {DomainsApiGetDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails(requestParameters: DomainsApiGetDetailsRequest, options?: AxiosRequestConfig): AxiosPromise<DomainDetailV2> {
            return localVarFp.getDetails(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
         * @summary Retrieve the forwarding information for the given fqdn
         * @param {DomainsApiGetForwardingInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForwardingInfo(requestParameters: DomainsApiGetForwardingInfoRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DomainForwarding>> {
            return localVarFp.getForwardingInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the schema to be submitted when registering a Domain for the specified TLD
         * @param {DomainsApiGetRegisterSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisterSchema(requestParameters: DomainsApiGetRegisterSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<JsonSchema> {
            return localVarFp.getRegisterSchema(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the details for an upcoming system Maintenances
         * @param {DomainsApiGetUpcomingMaintenanceDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingMaintenanceDetails(requestParameters: DomainsApiGetUpcomingMaintenanceDetailsRequest, options?: AxiosRequestConfig): AxiosPromise<MaintenanceDetail> {
            return localVarFp.getUpcomingMaintenanceDetails(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of upcoming system Maintenances
         * @param {DomainsApiGetUpcomingMaintenancesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingMaintenancesList(requestParameters: DomainsApiGetUpcomingMaintenancesListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Maintenance> {
            return localVarFp.getUpcomingMaintenancesList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiate transfer out to another registrar for a .uk domain.
         * @param {DomainsApiInitiateTransferOutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateTransferOut(requestParameters: DomainsApiInitiateTransferOutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.initiateTransferOut(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
         * @summary Modify the forwarding information for the given fqdn
         * @param {DomainsApiModifyForwardingInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyForwardingInfo(requestParameters: DomainsApiModifyForwardingInfoRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.modifyForwardingInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase and register the specified Domain
         * @param {DomainsApiPurchaseRegisterDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseRegisterDomain(requestParameters: DomainsApiPurchaseRegisterDomainRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.purchaseRegisterDomain(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase and start or restart transfer process
         * @param {DomainsApiPurchaseTransferProcessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseTransferProcess(requestParameters: DomainsApiPurchaseTransferProcessRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.purchaseTransferProcess(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase a restore for the given domain to bring it out of redemption
         * @param {DomainsApiRedeemDomainRestoreRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemDomainRestore(requestParameters: DomainsApiRedeemDomainRestoreRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.redeemDomainRestore(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reject transfer out
         * @param {DomainsApiRejectTransferOutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectTransferOut(requestParameters: DomainsApiRejectTransferOutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rejectTransferOut(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Renew the specified Domain
         * @param {DomainsApiRenewDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewDomain(requestParameters: DomainsApiRenewDomainRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.renewDomain(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restarts transfer in request from the beginning
         * @param {DomainsApiRestartTransferInRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartTransferIn(requestParameters: DomainsApiRestartTransferInRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restartTransferIn(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retries the current transfer in request with supplied Authorization code
         * @param {DomainsApiRetryTransferInProcessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryTransferInProcess(requestParameters: DomainsApiRetryTransferInProcessRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.retryTransferInProcess(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate the request body using the Domain Registration Schema for the specified TLD
         * @param {DomainsApiValidateDomainRegistrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDomainRegistration(requestParameters: DomainsApiValidateDomainRegistrationRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.validateDomainRegistration(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for acceptTransferIn operation in DomainsApi.
 * @export
 * @interface DomainsApiAcceptTransferInRequest
 */
export type DomainsApiAcceptTransferInRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiAcceptTransferIn
    */
    readonly customerId: string
    
    /**
    * Domain to accept the transfer in for
    * @type {string}
    * @memberof DomainsApiAcceptTransferIn
    */
    readonly domain: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiAcceptTransferIn
    */
    readonly xRequestId?: string
    
} & DomainTransferAuthCode

/**
 * Request parameters for acceptTransferOut operation in DomainsApi.
 * @export
 * @interface DomainsApiAcceptTransferOutRequest
 */
export type DomainsApiAcceptTransferOutRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiAcceptTransferOut
    */
    readonly customerId: string
    
    /**
    * Domain to accept the transfer out for
    * @type {string}
    * @memberof DomainsApiAcceptTransferOut
    */
    readonly domain: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiAcceptTransferOut
    */
    readonly xRequestId?: string
    
}

/**
 * Request parameters for cancelForwardingRequest operation in DomainsApi.
 * @export
 * @interface DomainsApiCancelForwardingRequestRequest
 */
export type DomainsApiCancelForwardingRequestRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiCancelForwardingRequest
    */
    readonly customerId: string
    
    /**
    * The fully qualified domain name whose forwarding details are to be deleted.
    * @type {string}
    * @memberof DomainsApiCancelForwardingRequest
    */
    readonly fqdn: string
    
}

/**
 * Request parameters for cancelTransferIn operation in DomainsApi.
 * @export
 * @interface DomainsApiCancelTransferInRequest
 */
export type DomainsApiCancelTransferInRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiCancelTransferIn
    */
    readonly customerId: string
    
    /**
    * Domain to cancel the transfer in for
    * @type {string}
    * @memberof DomainsApiCancelTransferIn
    */
    readonly domain: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiCancelTransferIn
    */
    readonly xRequestId?: string
    
}

/**
 * Request parameters for createForwardingConfiguration operation in DomainsApi.
 * @export
 * @interface DomainsApiCreateForwardingConfigurationRequest
 */
export type DomainsApiCreateForwardingConfigurationRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your own customer id.
    * @type {string}
    * @memberof DomainsApiCreateForwardingConfiguration
    */
    readonly customerId: string
    
    /**
    * The fully qualified domain name whose forwarding details are to be modified.
    * @type {string}
    * @memberof DomainsApiCreateForwardingConfiguration
    */
    readonly fqdn: string
    
} & DomainForwardingCreate

/**
 * Request parameters for getDetails operation in DomainsApi.
 * @export
 * @interface DomainsApiGetDetailsRequest
 */
export type DomainsApiGetDetailsRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiGetDetails
    */
    readonly customerId: string
    
    /**
    * Domain name whose details are to be retrieved
    * @type {string}
    * @memberof DomainsApiGetDetails
    */
    readonly domain: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiGetDetails
    */
    readonly xRequestId?: string
    
    /**
    * Optional details to be included in the response
    * @type {Array<'actions' | 'contacts' | 'dnssecRecords' | 'registryStatusCodes'>}
    * @memberof DomainsApiGetDetails
    */
    readonly includes?: Array<'actions' | 'contacts' | 'dnssecRecords' | 'registryStatusCodes'>
    
}

/**
 * Request parameters for getForwardingInfo operation in DomainsApi.
 * @export
 * @interface DomainsApiGetForwardingInfoRequest
 */
export type DomainsApiGetForwardingInfoRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiGetForwardingInfo
    */
    readonly customerId: string
    
    /**
    * The fully qualified domain name whose forwarding details are to be retrieved.
    * @type {string}
    * @memberof DomainsApiGetForwardingInfo
    */
    readonly fqdn: string
    
    /**
    * Optionally include all sub domains if the fqdn specified is a domain and not a sub domain.
    * @type {boolean}
    * @memberof DomainsApiGetForwardingInfo
    */
    readonly includeSubs?: boolean
    
}

/**
 * Request parameters for getRegisterSchema operation in DomainsApi.
 * @export
 * @interface DomainsApiGetRegisterSchemaRequest
 */
export type DomainsApiGetRegisterSchemaRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiGetRegisterSchema
    */
    readonly customerId: string
    
    /**
    * The Top-Level Domain whose schema should be retrieved
    * @type {string}
    * @memberof DomainsApiGetRegisterSchema
    */
    readonly tld: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiGetRegisterSchema
    */
    readonly xRequestId?: string
    
}

/**
 * Request parameters for getUpcomingMaintenanceDetails operation in DomainsApi.
 * @export
 * @interface DomainsApiGetUpcomingMaintenanceDetailsRequest
 */
export type DomainsApiGetUpcomingMaintenanceDetailsRequest = {
    
    /**
    * The identifier for the system maintenance
    * @type {string}
    * @memberof DomainsApiGetUpcomingMaintenanceDetails
    */
    readonly maintenanceId: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiGetUpcomingMaintenanceDetails
    */
    readonly xRequestId?: string
    
}

/**
 * Request parameters for getUpcomingMaintenancesList operation in DomainsApi.
 * @export
 * @interface DomainsApiGetUpcomingMaintenancesListRequest
 */
export type DomainsApiGetUpcomingMaintenancesListRequest = {
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiGetUpcomingMaintenancesList
    */
    readonly xRequestId?: string
    
    /**
    * Only include results with the selected `status` value.  Returns all results if omitted<br/><ul><li><strong style=\'margin-left: 12px;\'>ACTIVE</strong> - The upcoming maintenance is active.</li><li><strong style=\'margin-left: 12px;\'>CANCELLED</strong> - The upcoming maintenance has been cancelled.</li></ul>
    * @type {'ACTIVE' | 'CANCELLED'}
    * @memberof DomainsApiGetUpcomingMaintenancesList
    */
    readonly status?: 'ACTIVE' | 'CANCELLED'
    
    /**
    * Only include results with `modifiedAt` after the supplied date
    * @type {string}
    * @memberof DomainsApiGetUpcomingMaintenancesList
    */
    readonly modifiedAtAfter?: string
    
    /**
    * Only include results with `startsAt` after the supplied date
    * @type {string}
    * @memberof DomainsApiGetUpcomingMaintenancesList
    */
    readonly startsAtAfter?: string
    
    /**
    * Maximum number of results to return
    * @type {number}
    * @memberof DomainsApiGetUpcomingMaintenancesList
    */
    readonly limit?: number
    
}

/**
 * Request parameters for initiateTransferOut operation in DomainsApi.
 * @export
 * @interface DomainsApiInitiateTransferOutRequest
 */
export type DomainsApiInitiateTransferOutRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiInitiateTransferOut
    */
    readonly customerId: string
    
    /**
    * Domain to initiate the transfer out for
    * @type {string}
    * @memberof DomainsApiInitiateTransferOut
    */
    readonly domain: string
    
    /**
    * Registrar tag to push transfer to
    * @type {string}
    * @memberof DomainsApiInitiateTransferOut
    */
    readonly registrar: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiInitiateTransferOut
    */
    readonly xRequestId?: string
    
}

/**
 * Request parameters for modifyForwardingInfo operation in DomainsApi.
 * @export
 * @interface DomainsApiModifyForwardingInfoRequest
 */
export type DomainsApiModifyForwardingInfoRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiModifyForwardingInfo
    */
    readonly customerId: string
    
    /**
    * The fully qualified domain name whose forwarding details are to be modified.
    * @type {string}
    * @memberof DomainsApiModifyForwardingInfo
    */
    readonly fqdn: string
    
} & DomainForwardingCreate

/**
 * Request parameters for purchaseRegisterDomain operation in DomainsApi.
 * @export
 * @interface DomainsApiPurchaseRegisterDomainRequest
 */
export type DomainsApiPurchaseRegisterDomainRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiPurchaseRegisterDomain
    */
    readonly customerId: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiPurchaseRegisterDomain
    */
    readonly xRequestId?: string
    
} & DomainPurchaseV2

/**
 * Request parameters for purchaseTransferProcess operation in DomainsApi.
 * @export
 * @interface DomainsApiPurchaseTransferProcessRequest
 */
export type DomainsApiPurchaseTransferProcessRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiPurchaseTransferProcess
    */
    readonly customerId: string
    
    /**
    * Domain to transfer in
    * @type {string}
    * @memberof DomainsApiPurchaseTransferProcess
    */
    readonly domain: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiPurchaseTransferProcess
    */
    readonly xRequestId?: string
    
} & DomainTransferInV2

/**
 * Request parameters for redeemDomainRestore operation in DomainsApi.
 * @export
 * @interface DomainsApiRedeemDomainRestoreRequest
 */
export type DomainsApiRedeemDomainRestoreRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiRedeemDomainRestore
    */
    readonly customerId: string
    
    /**
    * Domain to request redeem for
    * @type {string}
    * @memberof DomainsApiRedeemDomainRestore
    */
    readonly domain: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiRedeemDomainRestore
    */
    readonly xRequestId?: string
    
} & DomainRedeemV2

/**
 * Request parameters for rejectTransferOut operation in DomainsApi.
 * @export
 * @interface DomainsApiRejectTransferOutRequest
 */
export type DomainsApiRejectTransferOutRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiRejectTransferOut
    */
    readonly customerId: string
    
    /**
    * Domain to reject the transfer out for
    * @type {string}
    * @memberof DomainsApiRejectTransferOut
    */
    readonly domain: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiRejectTransferOut
    */
    readonly xRequestId?: string
    
    /**
    * Transfer out reject reason
    * @type {'EVIDENCE_OF_FRAUD' | 'URDP_ACTION' | 'COURT_ORDER' | 'DISPUTE_OVER_IDENTITY' | 'NO_PAYMENT_FOR_PREVIOUS_REGISTRATION_PERIOD' | 'WRITTEN_OBJECTION' | 'TRANSFERRED_WITHIN_SIXTY_DAYS'}
    * @memberof DomainsApiRejectTransferOut
    */
    readonly reason?: 'EVIDENCE_OF_FRAUD' | 'URDP_ACTION' | 'COURT_ORDER' | 'DISPUTE_OVER_IDENTITY' | 'NO_PAYMENT_FOR_PREVIOUS_REGISTRATION_PERIOD' | 'WRITTEN_OBJECTION' | 'TRANSFERRED_WITHIN_SIXTY_DAYS'
    
}

/**
 * Request parameters for renewDomain operation in DomainsApi.
 * @export
 * @interface DomainsApiRenewDomainRequest
 */
export type DomainsApiRenewDomainRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiRenewDomain
    */
    readonly customerId: string
    
    /**
    * Domain to be renewed
    * @type {string}
    * @memberof DomainsApiRenewDomain
    */
    readonly domain: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiRenewDomain
    */
    readonly xRequestId?: string
    
} & DomainRenewV2

/**
 * Request parameters for restartTransferIn operation in DomainsApi.
 * @export
 * @interface DomainsApiRestartTransferInRequest
 */
export type DomainsApiRestartTransferInRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiRestartTransferIn
    */
    readonly customerId: string
    
    /**
    * Domain to restart the transfer in
    * @type {string}
    * @memberof DomainsApiRestartTransferIn
    */
    readonly domain: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiRestartTransferIn
    */
    readonly xRequestId?: string
    
}

/**
 * Request parameters for retryTransferInProcess operation in DomainsApi.
 * @export
 * @interface DomainsApiRetryTransferInProcessRequest
 */
export type DomainsApiRetryTransferInProcessRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiRetryTransferInProcess
    */
    readonly customerId: string
    
    /**
    * Domain to retry the transfer in
    * @type {string}
    * @memberof DomainsApiRetryTransferInProcess
    */
    readonly domain: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiRetryTransferInProcess
    */
    readonly xRequestId?: string
    
} & DomainTransferAuthCode

/**
 * Request parameters for validateDomainRegistration operation in DomainsApi.
 * @export
 * @interface DomainsApiValidateDomainRegistrationRequest
 */
export type DomainsApiValidateDomainRegistrationRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof DomainsApiValidateDomainRegistration
    */
    readonly customerId: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof DomainsApiValidateDomainRegistration
    */
    readonly xRequestId?: string
    
} & DomainPurchaseV2

/**
 * DomainsApiGenerated - object-oriented interface
 * @export
 * @class DomainsApiGenerated
 * @extends {BaseAPI}
 */
export class DomainsApiGenerated extends BaseAPI {
    /**
     * 
     * @summary Accepts the transfer in
     * @param {DomainsApiAcceptTransferInRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public acceptTransferIn(requestParameters: DomainsApiAcceptTransferInRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).acceptTransferIn(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept transfer out
     * @param {DomainsApiAcceptTransferOutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public acceptTransferOut(requestParameters: DomainsApiAcceptTransferOutRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).acceptTransferOut(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
     * @summary Submit a forwarding cancellation request for the given fqdn
     * @param {DomainsApiCancelForwardingRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public cancelForwardingRequest(requestParameters: DomainsApiCancelForwardingRequestRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).cancelForwardingRequest(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels the transfer in
     * @param {DomainsApiCancelTransferInRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public cancelTransferIn(requestParameters: DomainsApiCancelTransferInRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).cancelTransferIn(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
     * @summary Create a new forwarding configuration for the given FQDN
     * @param {DomainsApiCreateForwardingConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public createForwardingConfiguration(requestParameters: DomainsApiCreateForwardingConfigurationRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).createForwardingConfiguration(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve details for the specified Domain
     * @param {DomainsApiGetDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public getDetails(requestParameters: DomainsApiGetDetailsRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).getDetails(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
     * @summary Retrieve the forwarding information for the given fqdn
     * @param {DomainsApiGetForwardingInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public getForwardingInfo(requestParameters: DomainsApiGetForwardingInfoRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).getForwardingInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the schema to be submitted when registering a Domain for the specified TLD
     * @param {DomainsApiGetRegisterSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public getRegisterSchema(requestParameters: DomainsApiGetRegisterSchemaRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).getRegisterSchema(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the details for an upcoming system Maintenances
     * @param {DomainsApiGetUpcomingMaintenanceDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public getUpcomingMaintenanceDetails(requestParameters: DomainsApiGetUpcomingMaintenanceDetailsRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).getUpcomingMaintenanceDetails(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of upcoming system Maintenances
     * @param {DomainsApiGetUpcomingMaintenancesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public getUpcomingMaintenancesList(requestParameters: DomainsApiGetUpcomingMaintenancesListRequest = {}, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).getUpcomingMaintenancesList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiate transfer out to another registrar for a .uk domain.
     * @param {DomainsApiInitiateTransferOutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public initiateTransferOut(requestParameters: DomainsApiInitiateTransferOutRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).initiateTransferOut(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
     * @summary Modify the forwarding information for the given fqdn
     * @param {DomainsApiModifyForwardingInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public modifyForwardingInfo(requestParameters: DomainsApiModifyForwardingInfoRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).modifyForwardingInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase and register the specified Domain
     * @param {DomainsApiPurchaseRegisterDomainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public purchaseRegisterDomain(requestParameters: DomainsApiPurchaseRegisterDomainRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).purchaseRegisterDomain(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase and start or restart transfer process
     * @param {DomainsApiPurchaseTransferProcessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public purchaseTransferProcess(requestParameters: DomainsApiPurchaseTransferProcessRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).purchaseTransferProcess(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase a restore for the given domain to bring it out of redemption
     * @param {DomainsApiRedeemDomainRestoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public redeemDomainRestore(requestParameters: DomainsApiRedeemDomainRestoreRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).redeemDomainRestore(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reject transfer out
     * @param {DomainsApiRejectTransferOutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public rejectTransferOut(requestParameters: DomainsApiRejectTransferOutRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).rejectTransferOut(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Renew the specified Domain
     * @param {DomainsApiRenewDomainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public renewDomain(requestParameters: DomainsApiRenewDomainRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).renewDomain(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restarts transfer in request from the beginning
     * @param {DomainsApiRestartTransferInRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public restartTransferIn(requestParameters: DomainsApiRestartTransferInRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).restartTransferIn(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retries the current transfer in request with supplied Authorization code
     * @param {DomainsApiRetryTransferInProcessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public retryTransferInProcess(requestParameters: DomainsApiRetryTransferInProcessRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).retryTransferInProcess(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate the request body using the Domain Registration Schema for the specified TLD
     * @param {DomainsApiValidateDomainRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApiGenerated
     */
    public validateDomainRegistration(requestParameters: DomainsApiValidateDomainRegistrationRequest, options?: AxiosRequestConfig) {
        return DomainsApiFp(this.configuration).validateDomainRegistration(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
