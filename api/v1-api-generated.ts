/* tslint:disable */
/* eslint-disable */
/*


All the help and tools you need to grow online: Websites, Domains, Digital and Social Marketing - plus GoDaddy Guides with you every step of the way.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Consent } from '../models';
// @ts-ignore
import { ConsentDomainUpdate } from '../models';
// @ts-ignore
import { Contact } from '../models';
// @ts-ignore
import { DNSRecord } from '../models';
// @ts-ignore
import { DNSRecordCreateType } from '../models';
// @ts-ignore
import { DNSRecordCreateTypeName } from '../models';
// @ts-ignore
import { DomainAvailableBulk } from '../models';
// @ts-ignore
import { DomainAvailableBulkMixed } from '../models';
// @ts-ignore
import { DomainAvailableResponse } from '../models';
// @ts-ignore
import { DomainContacts } from '../models';
// @ts-ignore
import { DomainDetail } from '../models';
// @ts-ignore
import { DomainPurchase } from '../models';
// @ts-ignore
import { DomainPurchaseResponse } from '../models';
// @ts-ignore
import { DomainRenew } from '../models';
// @ts-ignore
import { DomainSuggestion } from '../models';
// @ts-ignore
import { DomainSummary } from '../models';
// @ts-ignore
import { DomainTransferIn } from '../models';
// @ts-ignore
import { DomainUpdate } from '../models';
// @ts-ignore
import { DomainsContactsBulk } from '../models';
// @ts-ignore
import { ErrorDomainContactsValidate } from '../models';
// @ts-ignore
import { ErrorLimit } from '../models';
// @ts-ignore
import { JsonSchema } from '../models';
// @ts-ignore
import { LegalAgreement } from '../models';
// @ts-ignore
import { PrivacyPurchase } from '../models';
// @ts-ignore
import { TldSummary } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * V1Api - axios parameter creator
 * @export
 */
export const V1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add the specified DNS Records to the specified Domain
         * @param {string} domain Domain whose DNS Records are to be augmented
         * @param {Array<DNSRecord>} dNSRecord DNS Records to add to whatever currently exists
         * @param {string} [xShopperId] Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDnsRecordsToDomain: async (domain: string, dNSRecord: Array<DNSRecord>, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('addDnsRecordsToDomain', 'domain', domain)
            // verify required parameter 'dNSRecord' is not null or undefined
            assertParamExists('addDnsRecordsToDomain', 'dNSRecord', dNSRecord)
            const localVarPath = `/v1/domains/{domain}/records`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: dNSRecord,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}/records',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(dNSRecord, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel a purchased domain
         * @param {string} domain Domain to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDomainPurchase: async (domain: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('cancelDomainPurchase', 'domain', domain)
            const localVarPath = `/v1/domains/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit a privacy cancellation request for the given domain
         * @param {string} domain Domain whose privacy is to be cancelled
         * @param {string} [xShopperId] Shopper ID of the owner of the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPrivacyRequest: async (domain: string, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('cancelPrivacyRequest', 'domain', domain)
            const localVarPath = `/v1/domains/{domain}/privacy`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}/privacy',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Determine whether or not the specified domain is available for purchase
         * @param {string} domain Domain name whose availability is to be checked
         * @param {'FAST' | 'FULL' | 'fast' | 'full'} [checkType] Optimize for time (\&#39;FAST\&#39;) or accuracy (\&#39;FULL\&#39;)
         * @param {boolean} [forTransfer] Whether or not to include domains available for transfer. If set to True, checkType is ignored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainAvailability: async (domain: string, checkType?: 'FAST' | 'FULL' | 'fast' | 'full', forTransfer?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('checkDomainAvailability', 'domain', domain)
            const localVarPath = `/v1/domains/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }

            if (checkType !== undefined) {
                localVarQueryParameter['checkType'] = checkType;
            }

            if (forTransfer !== undefined) {
                localVarQueryParameter['forTransfer'] = forTransfer;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/available',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Determine whether or not the specified domains are available for purchase
         * @param {Array<string>} requestBody Domain names for which to check availability
         * @param {'FAST' | 'FULL' | 'fast' | 'full'} [checkType] Optimize for time (\&#39;FAST\&#39;) or accuracy (\&#39;FULL\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainAvailabilityPost: async (requestBody: Array<string>, checkType?: 'FAST' | 'FULL' | 'fast' | 'full', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('checkDomainAvailabilityPost', 'requestBody', requestBody)
            const localVarPath = `/v1/domains/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (checkType !== undefined) {
                localVarQueryParameter['checkType'] = checkType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: requestBody,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/available',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase and register the specified Domain
         * @param {DomainPurchase} domainPurchase An instance document expected to match the JSON schema returned by &#x60;./schema/{tld}&#x60;
         * @param {string} [xShopperId] The Shopper for whom the domain should be purchased
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainPurchase: async (domainPurchase: DomainPurchase, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainPurchase' is not null or undefined
            assertParamExists('createDomainPurchase', 'domainPurchase', domainPurchase)
            const localVarPath = `/v1/domains/purchase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainPurchase,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/purchase',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainPurchase, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all DNS Records for the specified Domain with the specified Type and Name
         * @param {string} domain Domain whose DNS Records are to be deleted
         * @param {'A' | 'AAAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT'} type DNS Record Type for which DNS Records are to be deleted
         * @param {string} name DNS Record Name for which DNS Records are to be deleted
         * @param {string} [xShopperId] Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllDnsRecords: async (domain: string, type: 'A' | 'AAAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT', name: string, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('deleteAllDnsRecords', 'domain', domain)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteAllDnsRecords', 'type', type)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteAllDnsRecords', 'name', name)
            const localVarPath = `/v1/domains/{domain}/records/{type}/{name}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type !== undefined ? type : `-type-`)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name !== undefined ? name : `-name-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}/records/{type}/{name}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve DNS Records for the specified Domain, optionally with the specified Type and/or Name
         * @param {string} domain Domain whose DNS Records are to be retrieved
         * @param {'A' | 'AAAA' | 'CNAME' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'TXT'} type DNS Record Type for which DNS Records are to be retrieved
         * @param {string} name DNS Record Name for which DNS Records are to be retrieved
         * @param {string} [xShopperId] Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
         * @param {number} [offset] Number of results to skip for pagination
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDnsRecords: async (domain: string, type: 'A' | 'AAAA' | 'CNAME' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'TXT', name: string, xShopperId?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getDnsRecords', 'domain', domain)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getDnsRecords', 'type', type)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getDnsRecords', 'name', name)
            const localVarPath = `/v1/domains/{domain}/records/{type}/{name}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type !== undefined ? type : `-type-`)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name !== undefined ? name : `-name-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}/records/{type}/{name}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve details for the specified Domain
         * @param {string} domain Domain name whose details are to be retrieved
         * @param {string} [xShopperId] Shopper ID expected to own the specified domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainDetails: async (domain: string, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getDomainDetails', 'domain', domain)
            const localVarPath = `/v1/domains/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the schema to be submitted when registering a Domain for the specified TLD
         * @param {string} tld The Top-Level Domain whose schema should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainSchema: async (tld: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tld' is not null or undefined
            assertParamExists('getDomainSchema', 'tld', tld)
            const localVarPath = `/v1/domains/purchase/schema/{tld}`
                .replace(`{${"tld"}}`, encodeURIComponent(String(tld !== undefined ? tld : `-tld-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/purchase/schema/{tld}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of Domains for the specified Shopper
         * @param {string} [xShopperId] Shopper ID whose domains are to be retrieved
         * @param {Array<'ACTIVE' | 'AWAITING_CLAIM_ACK' | 'AWAITING_DOCUMENT_AFTER_TRANSFER' | 'AWAITING_DOCUMENT_AFTER_UPDATE_ACCOUNT' | 'AWAITING_DOCUMENT_UPLOAD' | 'AWAITING_FAILED_TRANSFER_WHOIS_PRIVACY' | 'AWAITING_PAYMENT' | 'AWAITING_RENEWAL_TRANSFER_IN_COMPLETE' | 'AWAITING_TRANSFER_IN_ACK' | 'AWAITING_TRANSFER_IN_AUTH' | 'AWAITING_TRANSFER_IN_AUTO' | 'AWAITING_TRANSFER_IN_WHOIS' | 'AWAITING_TRANSFER_IN_WHOIS_FIX' | 'AWAITING_VERIFICATION_ICANN' | 'AWAITING_VERIFICATION_ICANN_MANUAL' | 'CANCELLED' | 'CANCELLED_HELD' | 'CANCELLED_REDEEMABLE' | 'CANCELLED_TRANSFER' | 'CONFISCATED' | 'DISABLED_SPECIAL' | 'EXCLUDED_INVALID_CLAIM_FIREHOSE' | 'EXPIRED_REASSIGNED' | 'FAILED_BACKORDER_CAPTURE' | 'FAILED_DROP_IMMEDIATE_THEN_ADD' | 'FAILED_PRE_REGISTRATION' | 'FAILED_REDEMPTION' | 'FAILED_REDEMPTION_REPORT' | 'FAILED_REGISTRATION' | 'FAILED_REGISTRATION_FIREHOSE' | 'FAILED_RESTORATION_REDEMPTION_MOCK' | 'FAILED_SETUP' | 'FAILED_TRANSFER_IN' | 'FAILED_TRANSFER_IN_BAD_STATUS' | 'FAILED_TRANSFER_IN_REGISTRY' | 'HELD_COURT_ORDERED' | 'HELD_DISPUTED' | 'HELD_EXPIRATION_PROTECTION' | 'HELD_EXPIRED_REDEMPTION_MOCK' | 'HELD_REGISTRAR_ADD' | 'HELD_REGISTRAR_REMOVE' | 'HELD_SHOPPER' | 'HELD_TEMPORARY' | 'LOCKED_ABUSE' | 'LOCKED_COPYRIGHT' | 'LOCKED_REGISTRY' | 'LOCKED_SUPER' | 'PARKED_AND_HELD' | 'PARKED_EXPIRED' | 'PARKED_VERIFICATION_ICANN' | 'PENDING_ABORT_CANCEL_SETUP' | 'PENDING_AGREEMENT_PRE_REGISTRATION' | 'PENDING_APPLY_RENEWAL_CREDITS' | 'PENDING_BACKORDER_CAPTURE' | 'PENDING_BLOCKED_REGISTRY' | 'PENDING_CANCEL_REGISTRANT_PROFILE' | 'PENDING_COMPLETE_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_COMPLETE_REGISTRANT_PROFILE' | 'PENDING_COO' | 'PENDING_COO_COMPLETE' | 'PENDING_DNS' | 'PENDING_DNS_ACTIVE' | 'PENDING_DNS_INACTIVE' | 'PENDING_DOCUMENT_VALIDATION' | 'PENDING_DOCUMENT_VERIFICATION' | 'PENDING_DROP_IMMEDIATE' | 'PENDING_DROP_IMMEDIATE_THEN_ADD' | 'PENDING_EPP_CREATE' | 'PENDING_EPP_DELETE' | 'PENDING_EPP_UPDATE' | 'PENDING_ESCALATION_REGISTRY' | 'PENDING_EXPIRATION' | 'PENDING_EXPIRATION_RESPONSE' | 'PENDING_EXPIRATION_SYNC' | 'PENDING_EXPIRED_REASSIGNMENT' | 'PENDING_EXPIRE_AUTO_ADD' | 'PENDING_EXTEND_REGISTRANT_PROFILE' | 'PENDING_FAILED_COO' | 'PENDING_FAILED_EPP_CREATE' | 'PENDING_FAILED_HELD' | 'PENDING_FAILED_PURCHASE_PREMIUM' | 'PENDING_FAILED_RECONCILE_FIREHOSE' | 'PENDING_FAILED_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_FAILED_RELEASE_PREMIUM' | 'PENDING_FAILED_RENEW_EXPIRATION_PROTECTION' | 'PENDING_FAILED_RESERVE_PREMIUM' | 'PENDING_FAILED_SUBMIT_FIREHOSE' | 'PENDING_FAILED_TRANSFER_ACK_PREMIUM' | 'PENDING_FAILED_TRANSFER_IN_ACK_PREMIUM' | 'PENDING_FAILED_TRANSFER_IN_PREMIUM' | 'PENDING_FAILED_TRANSFER_PREMIUM' | 'PENDING_FAILED_TRANSFER_SUBMIT_PREMIUM' | 'PENDING_FAILED_UNLOCK_PREMIUM' | 'PENDING_FAILED_UPDATE_API' | 'PENDING_FRAUD_VERIFICATION' | 'PENDING_FRAUD_VERIFIED' | 'PENDING_GET_CONTACTS' | 'PENDING_GET_HOSTS' | 'PENDING_GET_NAME_SERVERS' | 'PENDING_GET_STATUS' | 'PENDING_HOLD_ESCROW' | 'PENDING_HOLD_REDEMPTION' | 'PENDING_LOCK_CLIENT_REMOVE' | 'PENDING_LOCK_DATA_QUALITY' | 'PENDING_LOCK_THEN_HOLD_REDEMPTION' | 'PENDING_PARKING_DETERMINATION' | 'PENDING_PARK_INVALID_WHOIS' | 'PENDING_PARK_INVALID_WHOIS_REMOVAL' | 'PENDING_PURCHASE_PREMIUM' | 'PENDING_RECONCILE' | 'PENDING_RECONCILE_FIREHOSE' | 'PENDING_REDEMPTION' | 'PENDING_REDEMPTION_REPORT' | 'PENDING_REDEMPTION_REPORT_COMPLETE' | 'PENDING_REDEMPTION_REPORT_SUBMITTED' | 'PENDING_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_REDEMPTION_WITHOUT_RECEIPT_MOCK' | 'PENDING_RELEASE_PREMIUM' | 'PENDING_REMOVAL' | 'PENDING_REMOVAL_HELD' | 'PENDING_REMOVAL_PARKED' | 'PENDING_REMOVAL_UNPARK' | 'PENDING_RENEWAL' | 'PENDING_RENEW_EXPIRATION_PROTECTION' | 'PENDING_RENEW_INFINITE' | 'PENDING_RENEW_LOCKED' | 'PENDING_RENEW_WITHOUT_RECEIPT' | 'PENDING_REPORT_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_RESERVE_PREMIUM' | 'PENDING_RESET_VERIFICATION_ICANN' | 'PENDING_RESPONSE_FIREHOSE' | 'PENDING_RESTORATION' | 'PENDING_RESTORATION_INACTIVE' | 'PENDING_RESTORATION_REDEMPTION_MOCK' | 'PENDING_RETRY_EPP_CREATE' | 'PENDING_RETRY_HELD' | 'PENDING_SEND_AUTH_CODE' | 'PENDING_SETUP' | 'PENDING_SETUP_ABANDON' | 'PENDING_SETUP_AGREEMENT_LANDRUSH' | 'PENDING_SETUP_AGREEMENT_SUNRISE2_A' | 'PENDING_SETUP_AGREEMENT_SUNRISE2_B' | 'PENDING_SETUP_AGREEMENT_SUNRISE2_C' | 'PENDING_SETUP_AUTH' | 'PENDING_SETUP_DNS' | 'PENDING_SETUP_FAILED' | 'PENDING_SETUP_REVIEW' | 'PENDING_SETUP_SUNRISE' | 'PENDING_SETUP_SUNRISE_PRE' | 'PENDING_SETUP_SUNRISE_RESPONSE' | 'PENDING_SUBMIT_FAILURE' | 'PENDING_SUBMIT_FIREHOSE' | 'PENDING_SUBMIT_HOLD_FIREHOSE' | 'PENDING_SUBMIT_HOLD_LANDRUSH' | 'PENDING_SUBMIT_HOLD_SUNRISE' | 'PENDING_SUBMIT_LANDRUSH' | 'PENDING_SUBMIT_RESPONSE_FIREHOSE' | 'PENDING_SUBMIT_RESPONSE_LANDRUSH' | 'PENDING_SUBMIT_RESPONSE_SUNRISE' | 'PENDING_SUBMIT_SUCCESS_FIREHOSE' | 'PENDING_SUBMIT_SUCCESS_LANDRUSH' | 'PENDING_SUBMIT_SUCCESS_SUNRISE' | 'PENDING_SUBMIT_SUNRISE' | 'PENDING_SUBMIT_WAITING_LANDRUSH' | 'PENDING_SUCCESS_PRE_REGISTRATION' | 'PENDING_SUSPENDED_DATA_QUALITY' | 'PENDING_TRANSFER_ACK_PREMIUM' | 'PENDING_TRANSFER_IN' | 'PENDING_TRANSFER_IN_ACK' | 'PENDING_TRANSFER_IN_ACK_PREMIUM' | 'PENDING_TRANSFER_IN_BAD_REGISTRANT' | 'PENDING_TRANSFER_IN_CANCEL' | 'PENDING_TRANSFER_IN_CANCEL_REGISTRY' | 'PENDING_TRANSFER_IN_COMPLETE_ACK' | 'PENDING_TRANSFER_IN_DELETE' | 'PENDING_TRANSFER_IN_LOCK' | 'PENDING_TRANSFER_IN_NACK' | 'PENDING_TRANSFER_IN_NOTIFICATION' | 'PENDING_TRANSFER_IN_PREMIUM' | 'PENDING_TRANSFER_IN_RELEASE' | 'PENDING_TRANSFER_IN_RESPONSE' | 'PENDING_TRANSFER_IN_UNDERAGE' | 'PENDING_TRANSFER_OUT' | 'PENDING_TRANSFER_OUT_ACK' | 'PENDING_TRANSFER_OUT_NACK' | 'PENDING_TRANSFER_OUT_PREMIUM' | 'PENDING_TRANSFER_OUT_UNDERAGE' | 'PENDING_TRANSFER_OUT_VALIDATION' | 'PENDING_TRANSFER_PREMIUM' | 'PENDING_TRANSFER_PREMUIM' | 'PENDING_TRANSFER_SUBMIT_PREMIUM' | 'PENDING_UNLOCK_DATA_QUALITY' | 'PENDING_UNLOCK_PREMIUM' | 'PENDING_UPDATE' | 'PENDING_UPDATED_REGISTRANT_DATA_QUALITY' | 'PENDING_UPDATE_ACCOUNT' | 'PENDING_UPDATE_API' | 'PENDING_UPDATE_API_RESPONSE' | 'PENDING_UPDATE_AUTH' | 'PENDING_UPDATE_CONTACTS' | 'PENDING_UPDATE_CONTACTS_PRIVACY' | 'PENDING_UPDATE_DNS' | 'PENDING_UPDATE_DNS_SECURITY' | 'PENDING_UPDATE_ELIGIBILITY' | 'PENDING_UPDATE_EPP_CONTACTS' | 'PENDING_UPDATE_MEMBERSHIP' | 'PENDING_UPDATE_OWNERSHIP' | 'PENDING_UPDATE_OWNERSHIP_AUTH_AUCTION' | 'PENDING_UPDATE_OWNERSHIP_HELD' | 'PENDING_UPDATE_REGISTRANT' | 'PENDING_UPDATE_REPO' | 'PENDING_VALIDATION_DATA_QUALITY' | 'PENDING_VERIFICATION_FRAUD' | 'PENDING_VERIFICATION_STATUS' | 'PENDING_VERIFY_REGISTRANT_DATA_QUALITY' | 'RESERVED' | 'RESERVED_PREMIUM' | 'REVERTED' | 'SUSPENDED_VERIFICATION_ICANN' | 'TRANSFERRED_OUT' | 'UNLOCKED_ABUSE' | 'UNLOCKED_SUPER' | 'UNPARKED_AND_UNHELD' | 'UPDATED_OWNERSHIP' | 'UPDATED_OWNERSHIP_HELD'>} [statuses] Only include results with &#x60;status&#x60; value in the specified set
         * @param {Array<'INACTIVE' | 'PRE_REGISTRATION' | 'REDEMPTION' | 'RENEWABLE' | 'VERIFICATION_ICANN' | 'VISIBLE'>} [statusGroups] Only include results with &#x60;status&#x60; value in any of the specified groups
         * @param {number} [limit] Maximum number of domains to return
         * @param {string} [marker] Marker Domain to use as the offset in results
         * @param {Array<'authCode' | 'contacts' | 'nameServers'>} [includes] Optional details to be included in the response
         * @param {string} [modifiedDate] Only include results that have been modified since the specified date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainsList: async (xShopperId?: string, statuses?: Array<'ACTIVE' | 'AWAITING_CLAIM_ACK' | 'AWAITING_DOCUMENT_AFTER_TRANSFER' | 'AWAITING_DOCUMENT_AFTER_UPDATE_ACCOUNT' | 'AWAITING_DOCUMENT_UPLOAD' | 'AWAITING_FAILED_TRANSFER_WHOIS_PRIVACY' | 'AWAITING_PAYMENT' | 'AWAITING_RENEWAL_TRANSFER_IN_COMPLETE' | 'AWAITING_TRANSFER_IN_ACK' | 'AWAITING_TRANSFER_IN_AUTH' | 'AWAITING_TRANSFER_IN_AUTO' | 'AWAITING_TRANSFER_IN_WHOIS' | 'AWAITING_TRANSFER_IN_WHOIS_FIX' | 'AWAITING_VERIFICATION_ICANN' | 'AWAITING_VERIFICATION_ICANN_MANUAL' | 'CANCELLED' | 'CANCELLED_HELD' | 'CANCELLED_REDEEMABLE' | 'CANCELLED_TRANSFER' | 'CONFISCATED' | 'DISABLED_SPECIAL' | 'EXCLUDED_INVALID_CLAIM_FIREHOSE' | 'EXPIRED_REASSIGNED' | 'FAILED_BACKORDER_CAPTURE' | 'FAILED_DROP_IMMEDIATE_THEN_ADD' | 'FAILED_PRE_REGISTRATION' | 'FAILED_REDEMPTION' | 'FAILED_REDEMPTION_REPORT' | 'FAILED_REGISTRATION' | 'FAILED_REGISTRATION_FIREHOSE' | 'FAILED_RESTORATION_REDEMPTION_MOCK' | 'FAILED_SETUP' | 'FAILED_TRANSFER_IN' | 'FAILED_TRANSFER_IN_BAD_STATUS' | 'FAILED_TRANSFER_IN_REGISTRY' | 'HELD_COURT_ORDERED' | 'HELD_DISPUTED' | 'HELD_EXPIRATION_PROTECTION' | 'HELD_EXPIRED_REDEMPTION_MOCK' | 'HELD_REGISTRAR_ADD' | 'HELD_REGISTRAR_REMOVE' | 'HELD_SHOPPER' | 'HELD_TEMPORARY' | 'LOCKED_ABUSE' | 'LOCKED_COPYRIGHT' | 'LOCKED_REGISTRY' | 'LOCKED_SUPER' | 'PARKED_AND_HELD' | 'PARKED_EXPIRED' | 'PARKED_VERIFICATION_ICANN' | 'PENDING_ABORT_CANCEL_SETUP' | 'PENDING_AGREEMENT_PRE_REGISTRATION' | 'PENDING_APPLY_RENEWAL_CREDITS' | 'PENDING_BACKORDER_CAPTURE' | 'PENDING_BLOCKED_REGISTRY' | 'PENDING_CANCEL_REGISTRANT_PROFILE' | 'PENDING_COMPLETE_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_COMPLETE_REGISTRANT_PROFILE' | 'PENDING_COO' | 'PENDING_COO_COMPLETE' | 'PENDING_DNS' | 'PENDING_DNS_ACTIVE' | 'PENDING_DNS_INACTIVE' | 'PENDING_DOCUMENT_VALIDATION' | 'PENDING_DOCUMENT_VERIFICATION' | 'PENDING_DROP_IMMEDIATE' | 'PENDING_DROP_IMMEDIATE_THEN_ADD' | 'PENDING_EPP_CREATE' | 'PENDING_EPP_DELETE' | 'PENDING_EPP_UPDATE' | 'PENDING_ESCALATION_REGISTRY' | 'PENDING_EXPIRATION' | 'PENDING_EXPIRATION_RESPONSE' | 'PENDING_EXPIRATION_SYNC' | 'PENDING_EXPIRED_REASSIGNMENT' | 'PENDING_EXPIRE_AUTO_ADD' | 'PENDING_EXTEND_REGISTRANT_PROFILE' | 'PENDING_FAILED_COO' | 'PENDING_FAILED_EPP_CREATE' | 'PENDING_FAILED_HELD' | 'PENDING_FAILED_PURCHASE_PREMIUM' | 'PENDING_FAILED_RECONCILE_FIREHOSE' | 'PENDING_FAILED_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_FAILED_RELEASE_PREMIUM' | 'PENDING_FAILED_RENEW_EXPIRATION_PROTECTION' | 'PENDING_FAILED_RESERVE_PREMIUM' | 'PENDING_FAILED_SUBMIT_FIREHOSE' | 'PENDING_FAILED_TRANSFER_ACK_PREMIUM' | 'PENDING_FAILED_TRANSFER_IN_ACK_PREMIUM' | 'PENDING_FAILED_TRANSFER_IN_PREMIUM' | 'PENDING_FAILED_TRANSFER_PREMIUM' | 'PENDING_FAILED_TRANSFER_SUBMIT_PREMIUM' | 'PENDING_FAILED_UNLOCK_PREMIUM' | 'PENDING_FAILED_UPDATE_API' | 'PENDING_FRAUD_VERIFICATION' | 'PENDING_FRAUD_VERIFIED' | 'PENDING_GET_CONTACTS' | 'PENDING_GET_HOSTS' | 'PENDING_GET_NAME_SERVERS' | 'PENDING_GET_STATUS' | 'PENDING_HOLD_ESCROW' | 'PENDING_HOLD_REDEMPTION' | 'PENDING_LOCK_CLIENT_REMOVE' | 'PENDING_LOCK_DATA_QUALITY' | 'PENDING_LOCK_THEN_HOLD_REDEMPTION' | 'PENDING_PARKING_DETERMINATION' | 'PENDING_PARK_INVALID_WHOIS' | 'PENDING_PARK_INVALID_WHOIS_REMOVAL' | 'PENDING_PURCHASE_PREMIUM' | 'PENDING_RECONCILE' | 'PENDING_RECONCILE_FIREHOSE' | 'PENDING_REDEMPTION' | 'PENDING_REDEMPTION_REPORT' | 'PENDING_REDEMPTION_REPORT_COMPLETE' | 'PENDING_REDEMPTION_REPORT_SUBMITTED' | 'PENDING_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_REDEMPTION_WITHOUT_RECEIPT_MOCK' | 'PENDING_RELEASE_PREMIUM' | 'PENDING_REMOVAL' | 'PENDING_REMOVAL_HELD' | 'PENDING_REMOVAL_PARKED' | 'PENDING_REMOVAL_UNPARK' | 'PENDING_RENEWAL' | 'PENDING_RENEW_EXPIRATION_PROTECTION' | 'PENDING_RENEW_INFINITE' | 'PENDING_RENEW_LOCKED' | 'PENDING_RENEW_WITHOUT_RECEIPT' | 'PENDING_REPORT_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_RESERVE_PREMIUM' | 'PENDING_RESET_VERIFICATION_ICANN' | 'PENDING_RESPONSE_FIREHOSE' | 'PENDING_RESTORATION' | 'PENDING_RESTORATION_INACTIVE' | 'PENDING_RESTORATION_REDEMPTION_MOCK' | 'PENDING_RETRY_EPP_CREATE' | 'PENDING_RETRY_HELD' | 'PENDING_SEND_AUTH_CODE' | 'PENDING_SETUP' | 'PENDING_SETUP_ABANDON' | 'PENDING_SETUP_AGREEMENT_LANDRUSH' | 'PENDING_SETUP_AGREEMENT_SUNRISE2_A' | 'PENDING_SETUP_AGREEMENT_SUNRISE2_B' | 'PENDING_SETUP_AGREEMENT_SUNRISE2_C' | 'PENDING_SETUP_AUTH' | 'PENDING_SETUP_DNS' | 'PENDING_SETUP_FAILED' | 'PENDING_SETUP_REVIEW' | 'PENDING_SETUP_SUNRISE' | 'PENDING_SETUP_SUNRISE_PRE' | 'PENDING_SETUP_SUNRISE_RESPONSE' | 'PENDING_SUBMIT_FAILURE' | 'PENDING_SUBMIT_FIREHOSE' | 'PENDING_SUBMIT_HOLD_FIREHOSE' | 'PENDING_SUBMIT_HOLD_LANDRUSH' | 'PENDING_SUBMIT_HOLD_SUNRISE' | 'PENDING_SUBMIT_LANDRUSH' | 'PENDING_SUBMIT_RESPONSE_FIREHOSE' | 'PENDING_SUBMIT_RESPONSE_LANDRUSH' | 'PENDING_SUBMIT_RESPONSE_SUNRISE' | 'PENDING_SUBMIT_SUCCESS_FIREHOSE' | 'PENDING_SUBMIT_SUCCESS_LANDRUSH' | 'PENDING_SUBMIT_SUCCESS_SUNRISE' | 'PENDING_SUBMIT_SUNRISE' | 'PENDING_SUBMIT_WAITING_LANDRUSH' | 'PENDING_SUCCESS_PRE_REGISTRATION' | 'PENDING_SUSPENDED_DATA_QUALITY' | 'PENDING_TRANSFER_ACK_PREMIUM' | 'PENDING_TRANSFER_IN' | 'PENDING_TRANSFER_IN_ACK' | 'PENDING_TRANSFER_IN_ACK_PREMIUM' | 'PENDING_TRANSFER_IN_BAD_REGISTRANT' | 'PENDING_TRANSFER_IN_CANCEL' | 'PENDING_TRANSFER_IN_CANCEL_REGISTRY' | 'PENDING_TRANSFER_IN_COMPLETE_ACK' | 'PENDING_TRANSFER_IN_DELETE' | 'PENDING_TRANSFER_IN_LOCK' | 'PENDING_TRANSFER_IN_NACK' | 'PENDING_TRANSFER_IN_NOTIFICATION' | 'PENDING_TRANSFER_IN_PREMIUM' | 'PENDING_TRANSFER_IN_RELEASE' | 'PENDING_TRANSFER_IN_RESPONSE' | 'PENDING_TRANSFER_IN_UNDERAGE' | 'PENDING_TRANSFER_OUT' | 'PENDING_TRANSFER_OUT_ACK' | 'PENDING_TRANSFER_OUT_NACK' | 'PENDING_TRANSFER_OUT_PREMIUM' | 'PENDING_TRANSFER_OUT_UNDERAGE' | 'PENDING_TRANSFER_OUT_VALIDATION' | 'PENDING_TRANSFER_PREMIUM' | 'PENDING_TRANSFER_PREMUIM' | 'PENDING_TRANSFER_SUBMIT_PREMIUM' | 'PENDING_UNLOCK_DATA_QUALITY' | 'PENDING_UNLOCK_PREMIUM' | 'PENDING_UPDATE' | 'PENDING_UPDATED_REGISTRANT_DATA_QUALITY' | 'PENDING_UPDATE_ACCOUNT' | 'PENDING_UPDATE_API' | 'PENDING_UPDATE_API_RESPONSE' | 'PENDING_UPDATE_AUTH' | 'PENDING_UPDATE_CONTACTS' | 'PENDING_UPDATE_CONTACTS_PRIVACY' | 'PENDING_UPDATE_DNS' | 'PENDING_UPDATE_DNS_SECURITY' | 'PENDING_UPDATE_ELIGIBILITY' | 'PENDING_UPDATE_EPP_CONTACTS' | 'PENDING_UPDATE_MEMBERSHIP' | 'PENDING_UPDATE_OWNERSHIP' | 'PENDING_UPDATE_OWNERSHIP_AUTH_AUCTION' | 'PENDING_UPDATE_OWNERSHIP_HELD' | 'PENDING_UPDATE_REGISTRANT' | 'PENDING_UPDATE_REPO' | 'PENDING_VALIDATION_DATA_QUALITY' | 'PENDING_VERIFICATION_FRAUD' | 'PENDING_VERIFICATION_STATUS' | 'PENDING_VERIFY_REGISTRANT_DATA_QUALITY' | 'RESERVED' | 'RESERVED_PREMIUM' | 'REVERTED' | 'SUSPENDED_VERIFICATION_ICANN' | 'TRANSFERRED_OUT' | 'UNLOCKED_ABUSE' | 'UNLOCKED_SUPER' | 'UNPARKED_AND_UNHELD' | 'UPDATED_OWNERSHIP' | 'UPDATED_OWNERSHIP_HELD'>, statusGroups?: Array<'INACTIVE' | 'PRE_REGISTRATION' | 'REDEMPTION' | 'RENEWABLE' | 'VERIFICATION_ICANN' | 'VISIBLE'>, limit?: number, marker?: string, includes?: Array<'authCode' | 'contacts' | 'nameServers'>, modifiedDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
            }

            if (statusGroups) {
                localVarQueryParameter['statusGroups'] = statusGroups.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (includes) {
                localVarQueryParameter['includes'] = includes.join(COLLECTION_FORMATS.csv);
            }

            if (modifiedDate !== undefined) {
                localVarQueryParameter['modifiedDate'] = modifiedDate;
            }

            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the legal agreement(s) required to purchase the specified TLD and add-ons
         * @param {Array<string>} tlds list of TLDs whose legal agreements are to be retrieved
         * @param {boolean} privacy Whether or not privacy has been requested
         * @param {string} [xMarketId] Unique identifier of the Market used to retrieve/translate Legal Agreements
         * @param {boolean} [forTransfer] Whether or not domain tranfer has been requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLegalAgreements: async (tlds: Array<string>, privacy: boolean, xMarketId?: string, forTransfer?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tlds' is not null or undefined
            assertParamExists('getLegalAgreements', 'tlds', tlds)
            // verify required parameter 'privacy' is not null or undefined
            assertParamExists('getLegalAgreements', 'privacy', privacy)
            const localVarPath = `/v1/domains/agreements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (tlds) {
                localVarQueryParameter['tlds'] = tlds.join(COLLECTION_FORMATS.csv);
            }

            if (privacy !== undefined) {
                localVarQueryParameter['privacy'] = privacy;
            }

            if (forTransfer !== undefined) {
                localVarQueryParameter['forTransfer'] = forTransfer;
            }

            if (xMarketId != null) {
                localVarHeaderParameter['X-Market-Id'] = String(xMarketId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/agreements',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a list of TLDs supported and enabled for sale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTldsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/domains/tlds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/tlds',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase privacy for a specified domain
         * @param {string} domain Domain for which to purchase privacy
         * @param {PrivacyPurchase} privacyPurchase Options for purchasing privacy
         * @param {string} [xShopperId] Shopper ID of the owner of the domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePrivacyForDomain: async (domain: string, privacyPurchase: PrivacyPurchase, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('purchasePrivacyForDomain', 'domain', domain)
            // verify required parameter 'privacyPurchase' is not null or undefined
            assertParamExists('purchasePrivacyForDomain', 'privacyPurchase', privacyPurchase)
            const localVarPath = `/v1/domains/{domain}/privacy/purchase`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: privacyPurchase,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}/privacy/purchase',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(privacyPurchase, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase and start or restart transfer process
         * @param {string} domain Domain to transfer in
         * @param {DomainTransferIn} domainTransferIn Details for domain transfer purchase
         * @param {string} [xShopperId] The Shopper to whom the domain should be transfered
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseTransferProcess: async (domain: string, domainTransferIn: DomainTransferIn, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('purchaseTransferProcess', 'domain', domain)
            // verify required parameter 'domainTransferIn' is not null or undefined
            assertParamExists('purchaseTransferProcess', 'domainTransferIn', domainTransferIn)
            const localVarPath = `/v1/domains/{domain}/transfer`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainTransferIn,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}/transfer',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainTransferIn, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Renew the specified Domain
         * @param {string} domain Domain to renew
         * @param {string} [xShopperId] Shopper for whom Domain is to be renewed. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
         * @param {DomainRenew} [domainRenew] Options for renewing existing Domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewDomain: async (domain: string, xShopperId?: string, domainRenew?: DomainRenew, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('renewDomain', 'domain', domain)
            const localVarPath = `/v1/domains/{domain}/renew`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainRenew,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}/renew',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainRenew, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace all DNS Records for the specified Domain
         * @param {string} domain Domain whose DNS Records are to be replaced
         * @param {Array<DNSRecord>} dNSRecord DNS Records to replace whatever currently exists
         * @param {string} [xShopperId] Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceDnsRecords: async (domain: string, dNSRecord: Array<DNSRecord>, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('replaceDnsRecords', 'domain', domain)
            // verify required parameter 'dNSRecord' is not null or undefined
            assertParamExists('replaceDnsRecords', 'dNSRecord', dNSRecord)
            const localVarPath = `/v1/domains/{domain}/records`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: dNSRecord,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}/records',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(dNSRecord, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace all DNS Records for the specified Domain with the specified Type
         * @param {string} domain Domain whose DNS Records are to be replaced
         * @param {'A' | 'AAAA' | 'CNAME' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'TXT'} type DNS Record Type for which DNS Records are to be replaced
         * @param {Array<DNSRecordCreateType>} dNSRecordCreateType DNS Records to replace whatever currently exists
         * @param {string} [xShopperId] Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceDnsRecordsType: async (domain: string, type: 'A' | 'AAAA' | 'CNAME' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'TXT', dNSRecordCreateType: Array<DNSRecordCreateType>, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('replaceDnsRecordsType', 'domain', domain)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('replaceDnsRecordsType', 'type', type)
            // verify required parameter 'dNSRecordCreateType' is not null or undefined
            assertParamExists('replaceDnsRecordsType', 'dNSRecordCreateType', dNSRecordCreateType)
            const localVarPath = `/v1/domains/{domain}/records/{type}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type !== undefined ? type : `-type-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: dNSRecordCreateType,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}/records/{type}',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(dNSRecordCreateType, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace all DNS Records for the specified Domain with the specified Type and Name
         * @param {string} domain Domain whose DNS Records are to be replaced
         * @param {'A' | 'AAAA' | 'CNAME' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'TXT'} type DNS Record Type for which DNS Records are to be replaced
         * @param {string} name DNS Record Name for which DNS Records are to be replaced
         * @param {Array<DNSRecordCreateTypeName>} dNSRecordCreateTypeName DNS Records to replace whatever currently exists
         * @param {string} [xShopperId] Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceDnsRecordsType_1: async (domain: string, type: 'A' | 'AAAA' | 'CNAME' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'TXT', name: string, dNSRecordCreateTypeName: Array<DNSRecordCreateTypeName>, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('replaceDnsRecordsType_1', 'domain', domain)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('replaceDnsRecordsType_1', 'type', type)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('replaceDnsRecordsType_1', 'name', name)
            // verify required parameter 'dNSRecordCreateTypeName' is not null or undefined
            assertParamExists('replaceDnsRecordsType_1', 'dNSRecordCreateTypeName', dNSRecordCreateTypeName)
            const localVarPath = `/v1/domains/{domain}/records/{type}/{name}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type !== undefined ? type : `-type-`)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name !== undefined ? name : `-name-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: dNSRecordCreateTypeName,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}/records/{type}/{name}',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(dNSRecordCreateTypeName, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Re-send Contact E-mail Verification for specified Domain
         * @param {string} domain Domain whose Contact E-mail should be verified.
         * @param {string} [xShopperId] Shopper for whom domain contact e-mail should be verified. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendContactEmailVerification: async (domain: string, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('resendContactEmailVerification', 'domain', domain)
            const localVarPath = `/v1/domains/{domain}/verifyRegistrantEmail`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}/verifyRegistrantEmail',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Suggest alternate Domain names based on a seed Domain, a set of keywords, or the shopper\'s purchase history
         * @param {string} [xShopperId] Shopper ID for which the suggestions are being generated
         * @param {string} [query] Domain name or set of keywords for which alternative domain names will be suggested
         * @param {'AC' | 'AD' | 'AE' | 'AF' | 'AG' | 'AI' | 'AL' | 'AM' | 'AO' | 'AQ' | 'AR' | 'AS' | 'AT' | 'AU' | 'AW' | 'AX' | 'AZ' | 'BA' | 'BB' | 'BD' | 'BE' | 'BF' | 'BG' | 'BH' | 'BI' | 'BJ' | 'BM' | 'BN' | 'BO' | 'BQ' | 'BR' | 'BS' | 'BT' | 'BV' | 'BW' | 'BY' | 'BZ' | 'CA' | 'CC' | 'CD' | 'CF' | 'CG' | 'CH' | 'CI' | 'CK' | 'CL' | 'CM' | 'CN' | 'CO' | 'CR' | 'CV' | 'CW' | 'CX' | 'CY' | 'CZ' | 'DE' | 'DJ' | 'DK' | 'DM' | 'DO' | 'DZ' | 'EC' | 'EE' | 'EG' | 'EH' | 'ER' | 'ES' | 'ET' | 'FI' | 'FJ' | 'FK' | 'FM' | 'FO' | 'FR' | 'GA' | 'GB' | 'GD' | 'GE' | 'GF' | 'GG' | 'GH' | 'GI' | 'GL' | 'GM' | 'GN' | 'GP' | 'GQ' | 'GR' | 'GS' | 'GT' | 'GU' | 'GW' | 'GY' | 'HK' | 'HM' | 'HN' | 'HR' | 'HT' | 'HU' | 'ID' | 'IE' | 'IL' | 'IM' | 'IN' | 'IO' | 'IQ' | 'IS' | 'IT' | 'JE' | 'JM' | 'JO' | 'JP' | 'KE' | 'KG' | 'KH' | 'KI' | 'KM' | 'KN' | 'KR' | 'KV' | 'KW' | 'KY' | 'KZ' | 'LA' | 'LB' | 'LC' | 'LI' | 'LK' | 'LR' | 'LS' | 'LT' | 'LU' | 'LV' | 'LY' | 'MA' | 'MC' | 'MD' | 'ME' | 'MG' | 'MH' | 'MK' | 'ML' | 'MM' | 'MN' | 'MO' | 'MP' | 'MQ' | 'MR' | 'MS' | 'MT' | 'MU' | 'MV' | 'MW' | 'MX' | 'MY' | 'MZ' | 'NA' | 'NC' | 'NE' | 'NF' | 'NG' | 'NI' | 'NL' | 'false' | 'NP' | 'NR' | 'NU' | 'NZ' | 'OM' | 'PA' | 'PE' | 'PF' | 'PG' | 'PH' | 'PK' | 'PL' | 'PM' | 'PN' | 'PR' | 'PS' | 'PT' | 'PW' | 'PY' | 'QA' | 'RE' | 'RO' | 'RS' | 'RU' | 'RW' | 'SA' | 'SB' | 'SC' | 'SE' | 'SG' | 'SH' | 'SI' | 'SJ' | 'SK' | 'SL' | 'SM' | 'SN' | 'SO' | 'SR' | 'ST' | 'SV' | 'SX' | 'SZ' | 'TC' | 'TD' | 'TF' | 'TG' | 'TH' | 'TJ' | 'TK' | 'TL' | 'TM' | 'TN' | 'TO' | 'TP' | 'TR' | 'TT' | 'TV' | 'TW' | 'TZ' | 'UA' | 'UG' | 'UM' | 'US' | 'UY' | 'UZ' | 'VA' | 'VC' | 'VE' | 'VG' | 'VI' | 'VN' | 'VU' | 'WF' | 'WS' | 'YE' | 'YT' | 'ZA' | 'ZM' | 'ZW'} [country] Two-letter ISO country code to be used as a hint for target region&lt;br/&gt;&lt;br/&gt; NOTE: These are sample values, there are many &lt;a href&#x3D;\&quot;http://www.iso.org/iso/country_codes.htm\&quot;&gt;more&lt;/a&gt;
         * @param {string} [city] Name of city to be used as a hint for target region
         * @param {Array<'CC_TLD' | 'EXTENSION' | 'KEYWORD_SPIN' | 'PREMIUM' | 'cctld' | 'extension' | 'keywordspin' | 'premium'>} [sources] Sources to be queried&lt;br/&gt;&lt;br/&gt;&lt;ul&gt; &lt;li&gt;&lt;strong&gt;CC_TLD&lt;/strong&gt; - Varies the TLD using Country Codes&lt;/li&gt; &lt;li&gt;&lt;strong&gt;EXTENSION&lt;/strong&gt; - Varies the TLD&lt;/li&gt; &lt;li&gt;&lt;strong&gt;KEYWORD_SPIN&lt;/strong&gt; - Identifies keywords and then rotates each one&lt;/li&gt; &lt;li&gt;&lt;strong&gt;PREMIUM&lt;/strong&gt; - Includes variations with premium prices&lt;/li&gt;&lt;/ul&gt;
         * @param {Array<string>} [tlds] Top-level domains to be included in suggestions&lt;br/&gt;&lt;br/&gt; NOTE: These are sample values, there are many &lt;a href&#x3D;\&quot;http://www.godaddy.com/tlds/gtld.aspx#domain_search_form\&quot;&gt;more&lt;/a&gt;
         * @param {number} [lengthMax] Maximum length of second-level domain
         * @param {number} [lengthMin] Minimum length of second-level domain
         * @param {number} [limit] Maximum number of suggestions to return
         * @param {number} [waitMs] Maximum amount of time, in milliseconds, to wait for responses If elapses, return the results compiled up to that point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestAlternateDomains: async (xShopperId?: string, query?: string, country?: 'AC' | 'AD' | 'AE' | 'AF' | 'AG' | 'AI' | 'AL' | 'AM' | 'AO' | 'AQ' | 'AR' | 'AS' | 'AT' | 'AU' | 'AW' | 'AX' | 'AZ' | 'BA' | 'BB' | 'BD' | 'BE' | 'BF' | 'BG' | 'BH' | 'BI' | 'BJ' | 'BM' | 'BN' | 'BO' | 'BQ' | 'BR' | 'BS' | 'BT' | 'BV' | 'BW' | 'BY' | 'BZ' | 'CA' | 'CC' | 'CD' | 'CF' | 'CG' | 'CH' | 'CI' | 'CK' | 'CL' | 'CM' | 'CN' | 'CO' | 'CR' | 'CV' | 'CW' | 'CX' | 'CY' | 'CZ' | 'DE' | 'DJ' | 'DK' | 'DM' | 'DO' | 'DZ' | 'EC' | 'EE' | 'EG' | 'EH' | 'ER' | 'ES' | 'ET' | 'FI' | 'FJ' | 'FK' | 'FM' | 'FO' | 'FR' | 'GA' | 'GB' | 'GD' | 'GE' | 'GF' | 'GG' | 'GH' | 'GI' | 'GL' | 'GM' | 'GN' | 'GP' | 'GQ' | 'GR' | 'GS' | 'GT' | 'GU' | 'GW' | 'GY' | 'HK' | 'HM' | 'HN' | 'HR' | 'HT' | 'HU' | 'ID' | 'IE' | 'IL' | 'IM' | 'IN' | 'IO' | 'IQ' | 'IS' | 'IT' | 'JE' | 'JM' | 'JO' | 'JP' | 'KE' | 'KG' | 'KH' | 'KI' | 'KM' | 'KN' | 'KR' | 'KV' | 'KW' | 'KY' | 'KZ' | 'LA' | 'LB' | 'LC' | 'LI' | 'LK' | 'LR' | 'LS' | 'LT' | 'LU' | 'LV' | 'LY' | 'MA' | 'MC' | 'MD' | 'ME' | 'MG' | 'MH' | 'MK' | 'ML' | 'MM' | 'MN' | 'MO' | 'MP' | 'MQ' | 'MR' | 'MS' | 'MT' | 'MU' | 'MV' | 'MW' | 'MX' | 'MY' | 'MZ' | 'NA' | 'NC' | 'NE' | 'NF' | 'NG' | 'NI' | 'NL' | 'false' | 'NP' | 'NR' | 'NU' | 'NZ' | 'OM' | 'PA' | 'PE' | 'PF' | 'PG' | 'PH' | 'PK' | 'PL' | 'PM' | 'PN' | 'PR' | 'PS' | 'PT' | 'PW' | 'PY' | 'QA' | 'RE' | 'RO' | 'RS' | 'RU' | 'RW' | 'SA' | 'SB' | 'SC' | 'SE' | 'SG' | 'SH' | 'SI' | 'SJ' | 'SK' | 'SL' | 'SM' | 'SN' | 'SO' | 'SR' | 'ST' | 'SV' | 'SX' | 'SZ' | 'TC' | 'TD' | 'TF' | 'TG' | 'TH' | 'TJ' | 'TK' | 'TL' | 'TM' | 'TN' | 'TO' | 'TP' | 'TR' | 'TT' | 'TV' | 'TW' | 'TZ' | 'UA' | 'UG' | 'UM' | 'US' | 'UY' | 'UZ' | 'VA' | 'VC' | 'VE' | 'VG' | 'VI' | 'VN' | 'VU' | 'WF' | 'WS' | 'YE' | 'YT' | 'ZA' | 'ZM' | 'ZW', city?: string, sources?: Array<'CC_TLD' | 'EXTENSION' | 'KEYWORD_SPIN' | 'PREMIUM' | 'cctld' | 'extension' | 'keywordspin' | 'premium'>, tlds?: Array<string>, lengthMax?: number, lengthMin?: number, limit?: number, waitMs?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/domains/suggest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (sources) {
                localVarQueryParameter['sources'] = sources.join(COLLECTION_FORMATS.csv);
            }

            if (tlds) {
                localVarQueryParameter['tlds'] = tlds.join(COLLECTION_FORMATS.csv);
            }

            if (lengthMax !== undefined) {
                localVarQueryParameter['lengthMax'] = lengthMax;
            }

            if (lengthMin !== undefined) {
                localVarQueryParameter['lengthMin'] = lengthMin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (waitMs !== undefined) {
                localVarQueryParameter['waitMs'] = waitMs;
            }

            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/suggest',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update domain
         * @param {string} domain Domain whose Contacts are to be updated.
         * @param {DomainContacts} domainContacts Changes to apply to existing Contacts
         * @param {string} [xShopperId] Shopper for whom domain contacts are to be updated. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContacts: async (domain: string, domainContacts: DomainContacts, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('updateDomainContacts', 'domain', domain)
            // verify required parameter 'domainContacts' is not null or undefined
            assertParamExists('updateDomainContacts', 'domainContacts', domainContacts)
            const localVarPath = `/v1/domains/{domain}/contacts`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainContacts,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}/contacts',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainContacts, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update details for the specified Domain
         * @param {string} domain Domain whose details are to be updated
         * @param {DomainUpdate} domainUpdate Changes to apply to existing Domain
         * @param {string} [xShopperId] Shopper for whom Domain is to be updated. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainDetails: async (domain: string, domainUpdate: DomainUpdate, xShopperId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('updateDomainDetails', 'domain', domain)
            // verify required parameter 'domainUpdate' is not null or undefined
            assertParamExists('updateDomainDetails', 'domainUpdate', domainUpdate)
            const localVarPath = `/v1/domains/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain !== undefined ? domain : `-domain-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xShopperId != null) {
                localVarHeaderParameter['X-Shopper-Id'] = String(xShopperId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainUpdate,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/{domain}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainUpdate, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All contacts specified in request will be validated against all domains specifed in \"domains\". As an alternative, you can also pass in tlds, with the exception of `uk`, which requires full domain names
         * @summary Validate the request body using the Domain Contact Validation Schema for specified domains.
         * @param {DomainsContactsBulk} domainsContactsBulk An instance document expected for domains contacts validation
         * @param {number} [xPrivateLabelId] PrivateLabelId to operate as, if different from JWT
         * @param {string} [marketId] MarketId in which the request is being made, and for which responses should be localized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDomainContacts: async (domainsContactsBulk: DomainsContactsBulk, xPrivateLabelId?: number, marketId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainsContactsBulk' is not null or undefined
            assertParamExists('validateDomainContacts', 'domainsContactsBulk', domainsContactsBulk)
            const localVarPath = `/v1/domains/contacts/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (marketId !== undefined) {
                localVarQueryParameter['marketId'] = marketId;
            }

            if (xPrivateLabelId != null) {
                localVarHeaderParameter['X-Private-Label-Id'] = typeof xPrivateLabelId === 'string'
                    ? xPrivateLabelId
                    : JSON.stringify(xPrivateLabelId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainsContactsBulk,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/contacts/validate',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainsContactsBulk, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate the request body using the Domain Purchase Schema for the specified TLD
         * @param {DomainPurchase} domainPurchase An instance document expected to match the JSON schema returned by &#x60;./schema/{tld}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDomainPurchase: async (domainPurchase: DomainPurchase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainPurchase' is not null or undefined
            assertParamExists('validateDomainPurchase', 'domainPurchase', domainPurchase)
            const localVarPath = `/v1/domains/purchase/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: domainPurchase,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/domains/purchase/validate',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(domainPurchase, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1Api - functional programming interface
 * @export
 */
export const V1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add the specified DNS Records to the specified Domain
         * @param {V1ApiAddDnsRecordsToDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDnsRecordsToDomain(requestParameters: V1ApiAddDnsRecordsToDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const dNSRecord: Array<DNSRecord> = requestParameters.requestBody;
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDnsRecordsToDomain(requestParameters.domain, dNSRecord, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel a purchased domain
         * @param {V1ApiCancelDomainPurchaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelDomainPurchase(requestParameters: V1ApiCancelDomainPurchaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelDomainPurchase(requestParameters.domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit a privacy cancellation request for the given domain
         * @param {V1ApiCancelPrivacyRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPrivacyRequest(requestParameters: V1ApiCancelPrivacyRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPrivacyRequest(requestParameters.domain, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Determine whether or not the specified domain is available for purchase
         * @param {V1ApiCheckDomainAvailabilityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDomainAvailability(requestParameters: V1ApiCheckDomainAvailabilityRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainAvailableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDomainAvailability(requestParameters.domain, requestParameters.checkType, requestParameters.forTransfer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Determine whether or not the specified domains are available for purchase
         * @param {V1ApiCheckDomainAvailabilityPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDomainAvailabilityPost(requestParameters: V1ApiCheckDomainAvailabilityPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainAvailableBulk>> {
            const requestBody: Array<string> = requestParameters.requestBody;
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDomainAvailabilityPost(requestBody, requestParameters.checkType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purchase and register the specified Domain
         * @param {V1ApiCreateDomainPurchaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomainPurchase(requestParameters: V1ApiCreateDomainPurchaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainPurchaseResponse>> {
            const domainPurchase: DomainPurchase = {
                consent: requestParameters.consent,
                contactAdmin: requestParameters.contactAdmin,
                contactBilling: requestParameters.contactBilling,
                contactRegistrant: requestParameters.contactRegistrant,
                contactTech: requestParameters.contactTech,
                domain: requestParameters.domain,
                nameServers: requestParameters.nameServers,
                period: requestParameters.period,
                privacy: requestParameters.privacy,
                renewAuto: requestParameters.renewAuto
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainPurchase(domainPurchase, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete all DNS Records for the specified Domain with the specified Type and Name
         * @param {V1ApiDeleteAllDnsRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllDnsRecords(requestParameters: V1ApiDeleteAllDnsRecordsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllDnsRecords(requestParameters.domain, requestParameters.type, requestParameters.name, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve DNS Records for the specified Domain, optionally with the specified Type and/or Name
         * @param {V1ApiGetDnsRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDnsRecords(requestParameters: V1ApiGetDnsRecordsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DNSRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDnsRecords(requestParameters.domain, requestParameters.type, requestParameters.name, requestParameters.xShopperId, requestParameters.offset, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve details for the specified Domain
         * @param {V1ApiGetDomainDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainDetails(requestParameters: V1ApiGetDomainDetailsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainDetails(requestParameters.domain, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the schema to be submitted when registering a Domain for the specified TLD
         * @param {V1ApiGetDomainSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainSchema(requestParameters: V1ApiGetDomainSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainSchema(requestParameters.tld, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of Domains for the specified Shopper
         * @param {V1ApiGetDomainsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainsList(requestParameters: V1ApiGetDomainsListRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainsList(requestParameters.xShopperId, requestParameters.statuses, requestParameters.statusGroups, requestParameters.limit, requestParameters.marker, requestParameters.includes, requestParameters.modifiedDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the legal agreement(s) required to purchase the specified TLD and add-ons
         * @param {V1ApiGetLegalAgreementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLegalAgreements(requestParameters: V1ApiGetLegalAgreementsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LegalAgreement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLegalAgreements(requestParameters.tlds, requestParameters.privacy, requestParameters.xMarketId, requestParameters.forTransfer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves a list of TLDs supported and enabled for sale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTldsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TldSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTldsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purchase privacy for a specified domain
         * @param {V1ApiPurchasePrivacyForDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchasePrivacyForDomain(requestParameters: V1ApiPurchasePrivacyForDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainPurchaseResponse>> {
            const privacyPurchase: PrivacyPurchase = {
                consent: requestParameters.consent
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchasePrivacyForDomain(requestParameters.domain, privacyPurchase, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purchase and start or restart transfer process
         * @param {V1ApiPurchaseTransferProcessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseTransferProcess(requestParameters: V1ApiPurchaseTransferProcessRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainPurchaseResponse>> {
            const domainTransferIn: DomainTransferIn = {
                authCode: requestParameters.authCode,
                consent: requestParameters.consent,
                contactAdmin: requestParameters.contactAdmin,
                contactBilling: requestParameters.contactBilling,
                contactRegistrant: requestParameters.contactRegistrant,
                contactTech: requestParameters.contactTech,
                period: requestParameters.period,
                privacy: requestParameters.privacy,
                renewAuto: requestParameters.renewAuto
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseTransferProcess(requestParameters.domain, domainTransferIn, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Renew the specified Domain
         * @param {V1ApiRenewDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renewDomain(requestParameters: V1ApiRenewDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainPurchaseResponse>> {
            const domainRenew: DomainRenew = {
                period: requestParameters.period
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.renewDomain(requestParameters.domain, requestParameters.xShopperId, domainRenew, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Replace all DNS Records for the specified Domain
         * @param {V1ApiReplaceDnsRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceDnsRecords(requestParameters: V1ApiReplaceDnsRecordsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const dNSRecord: Array<DNSRecord> = requestParameters.requestBody;
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceDnsRecords(requestParameters.domain, dNSRecord, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Replace all DNS Records for the specified Domain with the specified Type
         * @param {V1ApiReplaceDnsRecordsTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceDnsRecordsType(requestParameters: V1ApiReplaceDnsRecordsTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const dNSRecordCreateType: Array<DNSRecordCreateType> = requestParameters.requestBody;
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceDnsRecordsType(requestParameters.domain, requestParameters.type, dNSRecordCreateType, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Replace all DNS Records for the specified Domain with the specified Type and Name
         * @param {V1ApiReplaceDnsRecordsType0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceDnsRecordsType_1(requestParameters: V1ApiReplaceDnsRecordsType0Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const dNSRecordCreateTypeName: Array<DNSRecordCreateTypeName> = requestParameters.requestBody;
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceDnsRecordsType_1(requestParameters.domain, requestParameters.type, requestParameters.name, dNSRecordCreateTypeName, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Re-send Contact E-mail Verification for specified Domain
         * @param {V1ApiResendContactEmailVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendContactEmailVerification(requestParameters: V1ApiResendContactEmailVerificationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendContactEmailVerification(requestParameters.domain, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Suggest alternate Domain names based on a seed Domain, a set of keywords, or the shopper\'s purchase history
         * @param {V1ApiSuggestAlternateDomainsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestAlternateDomains(requestParameters: V1ApiSuggestAlternateDomainsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainSuggestion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestAlternateDomains(requestParameters.xShopperId, requestParameters.query, requestParameters.country, requestParameters.city, requestParameters.sources, requestParameters.tlds, requestParameters.lengthMax, requestParameters.lengthMin, requestParameters.limit, requestParameters.waitMs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update domain
         * @param {V1ApiUpdateDomainContactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContacts(requestParameters: V1ApiUpdateDomainContactsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainContacts: DomainContacts = {
                contactAdmin: requestParameters.contactAdmin,
                contactBilling: requestParameters.contactBilling,
                contactRegistrant: requestParameters.contactRegistrant,
                contactTech: requestParameters.contactTech
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContacts(requestParameters.domain, domainContacts, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update details for the specified Domain
         * @param {V1ApiUpdateDomainDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainDetails(requestParameters: V1ApiUpdateDomainDetailsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainUpdate: DomainUpdate = {
                consent: requestParameters.consent,
                exposeWhois: requestParameters.exposeWhois,
                locked: requestParameters.locked,
                nameServers: requestParameters.nameServers,
                renewAuto: requestParameters.renewAuto,
                subaccountId: requestParameters.subaccountId
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainDetails(requestParameters.domain, domainUpdate, requestParameters.xShopperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All contacts specified in request will be validated against all domains specifed in \"domains\". As an alternative, you can also pass in tlds, with the exception of `uk`, which requires full domain names
         * @summary Validate the request body using the Domain Contact Validation Schema for specified domains.
         * @param {V1ApiValidateDomainContactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateDomainContacts(requestParameters: V1ApiValidateDomainContactsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainsContactsBulk: DomainsContactsBulk = {
                contactAdmin: requestParameters.contactAdmin,
                contactBilling: requestParameters.contactBilling,
                contactPresence: requestParameters.contactPresence,
                contactRegistrant: requestParameters.contactRegistrant,
                contactTech: requestParameters.contactTech,
                domains: requestParameters.domains,
                entityType: requestParameters.entityType
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateDomainContacts(domainsContactsBulk, requestParameters.xPrivateLabelId, requestParameters.marketId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate the request body using the Domain Purchase Schema for the specified TLD
         * @param {V1ApiValidateDomainPurchaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateDomainPurchase(requestParameters: V1ApiValidateDomainPurchaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const domainPurchase: DomainPurchase = {
                consent: requestParameters.consent,
                contactAdmin: requestParameters.contactAdmin,
                contactBilling: requestParameters.contactBilling,
                contactRegistrant: requestParameters.contactRegistrant,
                contactTech: requestParameters.contactTech,
                domain: requestParameters.domain,
                nameServers: requestParameters.nameServers,
                period: requestParameters.period,
                privacy: requestParameters.privacy,
                renewAuto: requestParameters.renewAuto
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateDomainPurchase(domainPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1Api - factory interface
 * @export
 */
export const V1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1ApiFp(configuration)
    return {
        /**
         * 
         * @summary Add the specified DNS Records to the specified Domain
         * @param {V1ApiAddDnsRecordsToDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDnsRecordsToDomain(requestParameters: V1ApiAddDnsRecordsToDomainRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addDnsRecordsToDomain(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel a purchased domain
         * @param {V1ApiCancelDomainPurchaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDomainPurchase(requestParameters: V1ApiCancelDomainPurchaseRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelDomainPurchase(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit a privacy cancellation request for the given domain
         * @param {V1ApiCancelPrivacyRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPrivacyRequest(requestParameters: V1ApiCancelPrivacyRequestRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelPrivacyRequest(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Determine whether or not the specified domain is available for purchase
         * @param {V1ApiCheckDomainAvailabilityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainAvailability(requestParameters: V1ApiCheckDomainAvailabilityRequest, options?: AxiosRequestConfig): AxiosPromise<DomainAvailableResponse> {
            return localVarFp.checkDomainAvailability(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Determine whether or not the specified domains are available for purchase
         * @param {V1ApiCheckDomainAvailabilityPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainAvailabilityPost(requestParameters: V1ApiCheckDomainAvailabilityPostRequest, options?: AxiosRequestConfig): AxiosPromise<DomainAvailableBulk> {
            return localVarFp.checkDomainAvailabilityPost(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase and register the specified Domain
         * @param {V1ApiCreateDomainPurchaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainPurchase(requestParameters: V1ApiCreateDomainPurchaseRequest, options?: AxiosRequestConfig): AxiosPromise<DomainPurchaseResponse> {
            return localVarFp.createDomainPurchase(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all DNS Records for the specified Domain with the specified Type and Name
         * @param {V1ApiDeleteAllDnsRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllDnsRecords(requestParameters: V1ApiDeleteAllDnsRecordsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAllDnsRecords(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve DNS Records for the specified Domain, optionally with the specified Type and/or Name
         * @param {V1ApiGetDnsRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDnsRecords(requestParameters: V1ApiGetDnsRecordsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DNSRecord>> {
            return localVarFp.getDnsRecords(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve details for the specified Domain
         * @param {V1ApiGetDomainDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainDetails(requestParameters: V1ApiGetDomainDetailsRequest, options?: AxiosRequestConfig): AxiosPromise<DomainDetail> {
            return localVarFp.getDomainDetails(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the schema to be submitted when registering a Domain for the specified TLD
         * @param {V1ApiGetDomainSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainSchema(requestParameters: V1ApiGetDomainSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<JsonSchema> {
            return localVarFp.getDomainSchema(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of Domains for the specified Shopper
         * @param {V1ApiGetDomainsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainsList(requestParameters: V1ApiGetDomainsListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<DomainSummary>> {
            return localVarFp.getDomainsList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the legal agreement(s) required to purchase the specified TLD and add-ons
         * @param {V1ApiGetLegalAgreementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLegalAgreements(requestParameters: V1ApiGetLegalAgreementsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<LegalAgreement>> {
            return localVarFp.getLegalAgreements(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a list of TLDs supported and enabled for sale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTldsList(options?: AxiosRequestConfig): AxiosPromise<Array<TldSummary>> {
            return localVarFp.getTldsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase privacy for a specified domain
         * @param {V1ApiPurchasePrivacyForDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePrivacyForDomain(requestParameters: V1ApiPurchasePrivacyForDomainRequest, options?: AxiosRequestConfig): AxiosPromise<DomainPurchaseResponse> {
            return localVarFp.purchasePrivacyForDomain(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase and start or restart transfer process
         * @param {V1ApiPurchaseTransferProcessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseTransferProcess(requestParameters: V1ApiPurchaseTransferProcessRequest, options?: AxiosRequestConfig): AxiosPromise<DomainPurchaseResponse> {
            return localVarFp.purchaseTransferProcess(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Renew the specified Domain
         * @param {V1ApiRenewDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewDomain(requestParameters: V1ApiRenewDomainRequest, options?: AxiosRequestConfig): AxiosPromise<DomainPurchaseResponse> {
            return localVarFp.renewDomain(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace all DNS Records for the specified Domain
         * @param {V1ApiReplaceDnsRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceDnsRecords(requestParameters: V1ApiReplaceDnsRecordsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.replaceDnsRecords(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace all DNS Records for the specified Domain with the specified Type
         * @param {V1ApiReplaceDnsRecordsTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceDnsRecordsType(requestParameters: V1ApiReplaceDnsRecordsTypeRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.replaceDnsRecordsType(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace all DNS Records for the specified Domain with the specified Type and Name
         * @param {V1ApiReplaceDnsRecordsType0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceDnsRecordsType_1(requestParameters: V1ApiReplaceDnsRecordsType0Request, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.replaceDnsRecordsType_1(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Re-send Contact E-mail Verification for specified Domain
         * @param {V1ApiResendContactEmailVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendContactEmailVerification(requestParameters: V1ApiResendContactEmailVerificationRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendContactEmailVerification(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Suggest alternate Domain names based on a seed Domain, a set of keywords, or the shopper\'s purchase history
         * @param {V1ApiSuggestAlternateDomainsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestAlternateDomains(requestParameters: V1ApiSuggestAlternateDomainsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<DomainSuggestion>> {
            return localVarFp.suggestAlternateDomains(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update domain
         * @param {V1ApiUpdateDomainContactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContacts(requestParameters: V1ApiUpdateDomainContactsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDomainContacts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update details for the specified Domain
         * @param {V1ApiUpdateDomainDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainDetails(requestParameters: V1ApiUpdateDomainDetailsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDomainDetails(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * All contacts specified in request will be validated against all domains specifed in \"domains\". As an alternative, you can also pass in tlds, with the exception of `uk`, which requires full domain names
         * @summary Validate the request body using the Domain Contact Validation Schema for specified domains.
         * @param {V1ApiValidateDomainContactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDomainContacts(requestParameters: V1ApiValidateDomainContactsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.validateDomainContacts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate the request body using the Domain Purchase Schema for the specified TLD
         * @param {V1ApiValidateDomainPurchaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDomainPurchase(requestParameters: V1ApiValidateDomainPurchaseRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.validateDomainPurchase(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addDnsRecordsToDomain operation in V1Api.
 * @export
 * @interface V1ApiAddDnsRecordsToDomainRequest
 */
export type V1ApiAddDnsRecordsToDomainRequest = {
    /**
    * Domain whose DNS Records are to be augmented
    * @type {string}
    * @memberof V1ApiAddDnsRecordsToDomain
    */
    readonly domain: string
    /**
    * DNS Records to add to whatever currently exists
    * @type {Array<DNSRecord>}
    * @memberof V1ApiAddDnsRecordsToDomain
    */
    readonly requestBody: Array<DNSRecord>
    /**
    * Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\'re a Reseller, but purchased a Domain via http://www.godaddy.com
    * @type {string}
    * @memberof V1ApiAddDnsRecordsToDomain
    */
    readonly xShopperId?: string
}

/**
 * Request parameters for cancelDomainPurchase operation in V1Api.
 * @export
 * @interface V1ApiCancelDomainPurchaseRequest
 */
export type V1ApiCancelDomainPurchaseRequest = {
    
    /**
    * Domain to cancel
    * @type {string}
    * @memberof V1ApiCancelDomainPurchase
    */
    readonly domain: string
    
}

/**
 * Request parameters for cancelPrivacyRequest operation in V1Api.
 * @export
 * @interface V1ApiCancelPrivacyRequestRequest
 */
export type V1ApiCancelPrivacyRequestRequest = {
    
    /**
    * Domain whose privacy is to be cancelled
    * @type {string}
    * @memberof V1ApiCancelPrivacyRequest
    */
    readonly domain: string
    
    /**
    * Shopper ID of the owner of the domain
    * @type {string}
    * @memberof V1ApiCancelPrivacyRequest
    */
    readonly xShopperId?: string
    
}

/**
 * Request parameters for checkDomainAvailability operation in V1Api.
 * @export
 * @interface V1ApiCheckDomainAvailabilityRequest
 */
export type V1ApiCheckDomainAvailabilityRequest = {
    
    /**
    * Domain name whose availability is to be checked
    * @type {string}
    * @memberof V1ApiCheckDomainAvailability
    */
    readonly domain: string
    
    /**
    * Optimize for time (\'FAST\') or accuracy (\'FULL\')
    * @type {'FAST' | 'FULL' | 'fast' | 'full'}
    * @memberof V1ApiCheckDomainAvailability
    */
    readonly checkType?: 'FAST' | 'FULL' | 'fast' | 'full'
    
    /**
    * Whether or not to include domains available for transfer. If set to True, checkType is ignored
    * @type {boolean}
    * @memberof V1ApiCheckDomainAvailability
    */
    readonly forTransfer?: boolean
    
}

/**
 * Request parameters for checkDomainAvailabilityPost operation in V1Api.
 * @export
 * @interface V1ApiCheckDomainAvailabilityPostRequest
 */
export type V1ApiCheckDomainAvailabilityPostRequest = {
    /**
    * Domain names for which to check availability
    * @type {Array<string>}
    * @memberof V1ApiCheckDomainAvailabilityPost
    */
    readonly requestBody: Array<string>
    /**
    * Optimize for time (\'FAST\') or accuracy (\'FULL\')
    * @type {'FAST' | 'FULL' | 'fast' | 'full'}
    * @memberof V1ApiCheckDomainAvailabilityPost
    */
    readonly checkType?: 'FAST' | 'FULL' | 'fast' | 'full'
}

/**
 * Request parameters for createDomainPurchase operation in V1Api.
 * @export
 * @interface V1ApiCreateDomainPurchaseRequest
 */
export type V1ApiCreateDomainPurchaseRequest = {
    
    /**
    * The Shopper for whom the domain should be purchased
    * @type {string}
    * @memberof V1ApiCreateDomainPurchase
    */
    readonly xShopperId?: string
    
} & DomainPurchase

/**
 * Request parameters for deleteAllDnsRecords operation in V1Api.
 * @export
 * @interface V1ApiDeleteAllDnsRecordsRequest
 */
export type V1ApiDeleteAllDnsRecordsRequest = {
    
    /**
    * Domain whose DNS Records are to be deleted
    * @type {string}
    * @memberof V1ApiDeleteAllDnsRecords
    */
    readonly domain: string
    
    /**
    * DNS Record Type for which DNS Records are to be deleted
    * @type {'A' | 'AAAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT'}
    * @memberof V1ApiDeleteAllDnsRecords
    */
    readonly type: 'A' | 'AAAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT'
    
    /**
    * DNS Record Name for which DNS Records are to be deleted
    * @type {string}
    * @memberof V1ApiDeleteAllDnsRecords
    */
    readonly name: string
    
    /**
    * Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\'re a Reseller, but purchased a Domain via http://www.godaddy.com
    * @type {string}
    * @memberof V1ApiDeleteAllDnsRecords
    */
    readonly xShopperId?: string
    
}

/**
 * Request parameters for getDnsRecords operation in V1Api.
 * @export
 * @interface V1ApiGetDnsRecordsRequest
 */
export type V1ApiGetDnsRecordsRequest = {
    
    /**
    * Domain whose DNS Records are to be retrieved
    * @type {string}
    * @memberof V1ApiGetDnsRecords
    */
    readonly domain: string
    
    /**
    * DNS Record Type for which DNS Records are to be retrieved
    * @type {'A' | 'AAAA' | 'CNAME' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'TXT'}
    * @memberof V1ApiGetDnsRecords
    */
    readonly type: 'A' | 'AAAA' | 'CNAME' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'TXT'
    
    /**
    * DNS Record Name for which DNS Records are to be retrieved
    * @type {string}
    * @memberof V1ApiGetDnsRecords
    */
    readonly name: string
    
    /**
    * Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\'re a Reseller, but purchased a Domain via http://www.godaddy.com
    * @type {string}
    * @memberof V1ApiGetDnsRecords
    */
    readonly xShopperId?: string
    
    /**
    * Number of results to skip for pagination
    * @type {number}
    * @memberof V1ApiGetDnsRecords
    */
    readonly offset?: number
    
    /**
    * Maximum number of items to return
    * @type {number}
    * @memberof V1ApiGetDnsRecords
    */
    readonly limit?: number
    
}

/**
 * Request parameters for getDomainDetails operation in V1Api.
 * @export
 * @interface V1ApiGetDomainDetailsRequest
 */
export type V1ApiGetDomainDetailsRequest = {
    
    /**
    * Domain name whose details are to be retrieved
    * @type {string}
    * @memberof V1ApiGetDomainDetails
    */
    readonly domain: string
    
    /**
    * Shopper ID expected to own the specified domain
    * @type {string}
    * @memberof V1ApiGetDomainDetails
    */
    readonly xShopperId?: string
    
}

/**
 * Request parameters for getDomainSchema operation in V1Api.
 * @export
 * @interface V1ApiGetDomainSchemaRequest
 */
export type V1ApiGetDomainSchemaRequest = {
    
    /**
    * The Top-Level Domain whose schema should be retrieved
    * @type {string}
    * @memberof V1ApiGetDomainSchema
    */
    readonly tld: string
    
}

/**
 * Request parameters for getDomainsList operation in V1Api.
 * @export
 * @interface V1ApiGetDomainsListRequest
 */
export type V1ApiGetDomainsListRequest = {
    
    /**
    * Shopper ID whose domains are to be retrieved
    * @type {string}
    * @memberof V1ApiGetDomainsList
    */
    readonly xShopperId?: string
    
    /**
    * Only include results with `status` value in the specified set
    * @type {Array<'ACTIVE' | 'AWAITING_CLAIM_ACK' | 'AWAITING_DOCUMENT_AFTER_TRANSFER' | 'AWAITING_DOCUMENT_AFTER_UPDATE_ACCOUNT' | 'AWAITING_DOCUMENT_UPLOAD' | 'AWAITING_FAILED_TRANSFER_WHOIS_PRIVACY' | 'AWAITING_PAYMENT' | 'AWAITING_RENEWAL_TRANSFER_IN_COMPLETE' | 'AWAITING_TRANSFER_IN_ACK' | 'AWAITING_TRANSFER_IN_AUTH' | 'AWAITING_TRANSFER_IN_AUTO' | 'AWAITING_TRANSFER_IN_WHOIS' | 'AWAITING_TRANSFER_IN_WHOIS_FIX' | 'AWAITING_VERIFICATION_ICANN' | 'AWAITING_VERIFICATION_ICANN_MANUAL' | 'CANCELLED' | 'CANCELLED_HELD' | 'CANCELLED_REDEEMABLE' | 'CANCELLED_TRANSFER' | 'CONFISCATED' | 'DISABLED_SPECIAL' | 'EXCLUDED_INVALID_CLAIM_FIREHOSE' | 'EXPIRED_REASSIGNED' | 'FAILED_BACKORDER_CAPTURE' | 'FAILED_DROP_IMMEDIATE_THEN_ADD' | 'FAILED_PRE_REGISTRATION' | 'FAILED_REDEMPTION' | 'FAILED_REDEMPTION_REPORT' | 'FAILED_REGISTRATION' | 'FAILED_REGISTRATION_FIREHOSE' | 'FAILED_RESTORATION_REDEMPTION_MOCK' | 'FAILED_SETUP' | 'FAILED_TRANSFER_IN' | 'FAILED_TRANSFER_IN_BAD_STATUS' | 'FAILED_TRANSFER_IN_REGISTRY' | 'HELD_COURT_ORDERED' | 'HELD_DISPUTED' | 'HELD_EXPIRATION_PROTECTION' | 'HELD_EXPIRED_REDEMPTION_MOCK' | 'HELD_REGISTRAR_ADD' | 'HELD_REGISTRAR_REMOVE' | 'HELD_SHOPPER' | 'HELD_TEMPORARY' | 'LOCKED_ABUSE' | 'LOCKED_COPYRIGHT' | 'LOCKED_REGISTRY' | 'LOCKED_SUPER' | 'PARKED_AND_HELD' | 'PARKED_EXPIRED' | 'PARKED_VERIFICATION_ICANN' | 'PENDING_ABORT_CANCEL_SETUP' | 'PENDING_AGREEMENT_PRE_REGISTRATION' | 'PENDING_APPLY_RENEWAL_CREDITS' | 'PENDING_BACKORDER_CAPTURE' | 'PENDING_BLOCKED_REGISTRY' | 'PENDING_CANCEL_REGISTRANT_PROFILE' | 'PENDING_COMPLETE_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_COMPLETE_REGISTRANT_PROFILE' | 'PENDING_COO' | 'PENDING_COO_COMPLETE' | 'PENDING_DNS' | 'PENDING_DNS_ACTIVE' | 'PENDING_DNS_INACTIVE' | 'PENDING_DOCUMENT_VALIDATION' | 'PENDING_DOCUMENT_VERIFICATION' | 'PENDING_DROP_IMMEDIATE' | 'PENDING_DROP_IMMEDIATE_THEN_ADD' | 'PENDING_EPP_CREATE' | 'PENDING_EPP_DELETE' | 'PENDING_EPP_UPDATE' | 'PENDING_ESCALATION_REGISTRY' | 'PENDING_EXPIRATION' | 'PENDING_EXPIRATION_RESPONSE' | 'PENDING_EXPIRATION_SYNC' | 'PENDING_EXPIRED_REASSIGNMENT' | 'PENDING_EXPIRE_AUTO_ADD' | 'PENDING_EXTEND_REGISTRANT_PROFILE' | 'PENDING_FAILED_COO' | 'PENDING_FAILED_EPP_CREATE' | 'PENDING_FAILED_HELD' | 'PENDING_FAILED_PURCHASE_PREMIUM' | 'PENDING_FAILED_RECONCILE_FIREHOSE' | 'PENDING_FAILED_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_FAILED_RELEASE_PREMIUM' | 'PENDING_FAILED_RENEW_EXPIRATION_PROTECTION' | 'PENDING_FAILED_RESERVE_PREMIUM' | 'PENDING_FAILED_SUBMIT_FIREHOSE' | 'PENDING_FAILED_TRANSFER_ACK_PREMIUM' | 'PENDING_FAILED_TRANSFER_IN_ACK_PREMIUM' | 'PENDING_FAILED_TRANSFER_IN_PREMIUM' | 'PENDING_FAILED_TRANSFER_PREMIUM' | 'PENDING_FAILED_TRANSFER_SUBMIT_PREMIUM' | 'PENDING_FAILED_UNLOCK_PREMIUM' | 'PENDING_FAILED_UPDATE_API' | 'PENDING_FRAUD_VERIFICATION' | 'PENDING_FRAUD_VERIFIED' | 'PENDING_GET_CONTACTS' | 'PENDING_GET_HOSTS' | 'PENDING_GET_NAME_SERVERS' | 'PENDING_GET_STATUS' | 'PENDING_HOLD_ESCROW' | 'PENDING_HOLD_REDEMPTION' | 'PENDING_LOCK_CLIENT_REMOVE' | 'PENDING_LOCK_DATA_QUALITY' | 'PENDING_LOCK_THEN_HOLD_REDEMPTION' | 'PENDING_PARKING_DETERMINATION' | 'PENDING_PARK_INVALID_WHOIS' | 'PENDING_PARK_INVALID_WHOIS_REMOVAL' | 'PENDING_PURCHASE_PREMIUM' | 'PENDING_RECONCILE' | 'PENDING_RECONCILE_FIREHOSE' | 'PENDING_REDEMPTION' | 'PENDING_REDEMPTION_REPORT' | 'PENDING_REDEMPTION_REPORT_COMPLETE' | 'PENDING_REDEMPTION_REPORT_SUBMITTED' | 'PENDING_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_REDEMPTION_WITHOUT_RECEIPT_MOCK' | 'PENDING_RELEASE_PREMIUM' | 'PENDING_REMOVAL' | 'PENDING_REMOVAL_HELD' | 'PENDING_REMOVAL_PARKED' | 'PENDING_REMOVAL_UNPARK' | 'PENDING_RENEWAL' | 'PENDING_RENEW_EXPIRATION_PROTECTION' | 'PENDING_RENEW_INFINITE' | 'PENDING_RENEW_LOCKED' | 'PENDING_RENEW_WITHOUT_RECEIPT' | 'PENDING_REPORT_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_RESERVE_PREMIUM' | 'PENDING_RESET_VERIFICATION_ICANN' | 'PENDING_RESPONSE_FIREHOSE' | 'PENDING_RESTORATION' | 'PENDING_RESTORATION_INACTIVE' | 'PENDING_RESTORATION_REDEMPTION_MOCK' | 'PENDING_RETRY_EPP_CREATE' | 'PENDING_RETRY_HELD' | 'PENDING_SEND_AUTH_CODE' | 'PENDING_SETUP' | 'PENDING_SETUP_ABANDON' | 'PENDING_SETUP_AGREEMENT_LANDRUSH' | 'PENDING_SETUP_AGREEMENT_SUNRISE2_A' | 'PENDING_SETUP_AGREEMENT_SUNRISE2_B' | 'PENDING_SETUP_AGREEMENT_SUNRISE2_C' | 'PENDING_SETUP_AUTH' | 'PENDING_SETUP_DNS' | 'PENDING_SETUP_FAILED' | 'PENDING_SETUP_REVIEW' | 'PENDING_SETUP_SUNRISE' | 'PENDING_SETUP_SUNRISE_PRE' | 'PENDING_SETUP_SUNRISE_RESPONSE' | 'PENDING_SUBMIT_FAILURE' | 'PENDING_SUBMIT_FIREHOSE' | 'PENDING_SUBMIT_HOLD_FIREHOSE' | 'PENDING_SUBMIT_HOLD_LANDRUSH' | 'PENDING_SUBMIT_HOLD_SUNRISE' | 'PENDING_SUBMIT_LANDRUSH' | 'PENDING_SUBMIT_RESPONSE_FIREHOSE' | 'PENDING_SUBMIT_RESPONSE_LANDRUSH' | 'PENDING_SUBMIT_RESPONSE_SUNRISE' | 'PENDING_SUBMIT_SUCCESS_FIREHOSE' | 'PENDING_SUBMIT_SUCCESS_LANDRUSH' | 'PENDING_SUBMIT_SUCCESS_SUNRISE' | 'PENDING_SUBMIT_SUNRISE' | 'PENDING_SUBMIT_WAITING_LANDRUSH' | 'PENDING_SUCCESS_PRE_REGISTRATION' | 'PENDING_SUSPENDED_DATA_QUALITY' | 'PENDING_TRANSFER_ACK_PREMIUM' | 'PENDING_TRANSFER_IN' | 'PENDING_TRANSFER_IN_ACK' | 'PENDING_TRANSFER_IN_ACK_PREMIUM' | 'PENDING_TRANSFER_IN_BAD_REGISTRANT' | 'PENDING_TRANSFER_IN_CANCEL' | 'PENDING_TRANSFER_IN_CANCEL_REGISTRY' | 'PENDING_TRANSFER_IN_COMPLETE_ACK' | 'PENDING_TRANSFER_IN_DELETE' | 'PENDING_TRANSFER_IN_LOCK' | 'PENDING_TRANSFER_IN_NACK' | 'PENDING_TRANSFER_IN_NOTIFICATION' | 'PENDING_TRANSFER_IN_PREMIUM' | 'PENDING_TRANSFER_IN_RELEASE' | 'PENDING_TRANSFER_IN_RESPONSE' | 'PENDING_TRANSFER_IN_UNDERAGE' | 'PENDING_TRANSFER_OUT' | 'PENDING_TRANSFER_OUT_ACK' | 'PENDING_TRANSFER_OUT_NACK' | 'PENDING_TRANSFER_OUT_PREMIUM' | 'PENDING_TRANSFER_OUT_UNDERAGE' | 'PENDING_TRANSFER_OUT_VALIDATION' | 'PENDING_TRANSFER_PREMIUM' | 'PENDING_TRANSFER_PREMUIM' | 'PENDING_TRANSFER_SUBMIT_PREMIUM' | 'PENDING_UNLOCK_DATA_QUALITY' | 'PENDING_UNLOCK_PREMIUM' | 'PENDING_UPDATE' | 'PENDING_UPDATED_REGISTRANT_DATA_QUALITY' | 'PENDING_UPDATE_ACCOUNT' | 'PENDING_UPDATE_API' | 'PENDING_UPDATE_API_RESPONSE' | 'PENDING_UPDATE_AUTH' | 'PENDING_UPDATE_CONTACTS' | 'PENDING_UPDATE_CONTACTS_PRIVACY' | 'PENDING_UPDATE_DNS' | 'PENDING_UPDATE_DNS_SECURITY' | 'PENDING_UPDATE_ELIGIBILITY' | 'PENDING_UPDATE_EPP_CONTACTS' | 'PENDING_UPDATE_MEMBERSHIP' | 'PENDING_UPDATE_OWNERSHIP' | 'PENDING_UPDATE_OWNERSHIP_AUTH_AUCTION' | 'PENDING_UPDATE_OWNERSHIP_HELD' | 'PENDING_UPDATE_REGISTRANT' | 'PENDING_UPDATE_REPO' | 'PENDING_VALIDATION_DATA_QUALITY' | 'PENDING_VERIFICATION_FRAUD' | 'PENDING_VERIFICATION_STATUS' | 'PENDING_VERIFY_REGISTRANT_DATA_QUALITY' | 'RESERVED' | 'RESERVED_PREMIUM' | 'REVERTED' | 'SUSPENDED_VERIFICATION_ICANN' | 'TRANSFERRED_OUT' | 'UNLOCKED_ABUSE' | 'UNLOCKED_SUPER' | 'UNPARKED_AND_UNHELD' | 'UPDATED_OWNERSHIP' | 'UPDATED_OWNERSHIP_HELD'>}
    * @memberof V1ApiGetDomainsList
    */
    readonly statuses?: Array<'ACTIVE' | 'AWAITING_CLAIM_ACK' | 'AWAITING_DOCUMENT_AFTER_TRANSFER' | 'AWAITING_DOCUMENT_AFTER_UPDATE_ACCOUNT' | 'AWAITING_DOCUMENT_UPLOAD' | 'AWAITING_FAILED_TRANSFER_WHOIS_PRIVACY' | 'AWAITING_PAYMENT' | 'AWAITING_RENEWAL_TRANSFER_IN_COMPLETE' | 'AWAITING_TRANSFER_IN_ACK' | 'AWAITING_TRANSFER_IN_AUTH' | 'AWAITING_TRANSFER_IN_AUTO' | 'AWAITING_TRANSFER_IN_WHOIS' | 'AWAITING_TRANSFER_IN_WHOIS_FIX' | 'AWAITING_VERIFICATION_ICANN' | 'AWAITING_VERIFICATION_ICANN_MANUAL' | 'CANCELLED' | 'CANCELLED_HELD' | 'CANCELLED_REDEEMABLE' | 'CANCELLED_TRANSFER' | 'CONFISCATED' | 'DISABLED_SPECIAL' | 'EXCLUDED_INVALID_CLAIM_FIREHOSE' | 'EXPIRED_REASSIGNED' | 'FAILED_BACKORDER_CAPTURE' | 'FAILED_DROP_IMMEDIATE_THEN_ADD' | 'FAILED_PRE_REGISTRATION' | 'FAILED_REDEMPTION' | 'FAILED_REDEMPTION_REPORT' | 'FAILED_REGISTRATION' | 'FAILED_REGISTRATION_FIREHOSE' | 'FAILED_RESTORATION_REDEMPTION_MOCK' | 'FAILED_SETUP' | 'FAILED_TRANSFER_IN' | 'FAILED_TRANSFER_IN_BAD_STATUS' | 'FAILED_TRANSFER_IN_REGISTRY' | 'HELD_COURT_ORDERED' | 'HELD_DISPUTED' | 'HELD_EXPIRATION_PROTECTION' | 'HELD_EXPIRED_REDEMPTION_MOCK' | 'HELD_REGISTRAR_ADD' | 'HELD_REGISTRAR_REMOVE' | 'HELD_SHOPPER' | 'HELD_TEMPORARY' | 'LOCKED_ABUSE' | 'LOCKED_COPYRIGHT' | 'LOCKED_REGISTRY' | 'LOCKED_SUPER' | 'PARKED_AND_HELD' | 'PARKED_EXPIRED' | 'PARKED_VERIFICATION_ICANN' | 'PENDING_ABORT_CANCEL_SETUP' | 'PENDING_AGREEMENT_PRE_REGISTRATION' | 'PENDING_APPLY_RENEWAL_CREDITS' | 'PENDING_BACKORDER_CAPTURE' | 'PENDING_BLOCKED_REGISTRY' | 'PENDING_CANCEL_REGISTRANT_PROFILE' | 'PENDING_COMPLETE_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_COMPLETE_REGISTRANT_PROFILE' | 'PENDING_COO' | 'PENDING_COO_COMPLETE' | 'PENDING_DNS' | 'PENDING_DNS_ACTIVE' | 'PENDING_DNS_INACTIVE' | 'PENDING_DOCUMENT_VALIDATION' | 'PENDING_DOCUMENT_VERIFICATION' | 'PENDING_DROP_IMMEDIATE' | 'PENDING_DROP_IMMEDIATE_THEN_ADD' | 'PENDING_EPP_CREATE' | 'PENDING_EPP_DELETE' | 'PENDING_EPP_UPDATE' | 'PENDING_ESCALATION_REGISTRY' | 'PENDING_EXPIRATION' | 'PENDING_EXPIRATION_RESPONSE' | 'PENDING_EXPIRATION_SYNC' | 'PENDING_EXPIRED_REASSIGNMENT' | 'PENDING_EXPIRE_AUTO_ADD' | 'PENDING_EXTEND_REGISTRANT_PROFILE' | 'PENDING_FAILED_COO' | 'PENDING_FAILED_EPP_CREATE' | 'PENDING_FAILED_HELD' | 'PENDING_FAILED_PURCHASE_PREMIUM' | 'PENDING_FAILED_RECONCILE_FIREHOSE' | 'PENDING_FAILED_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_FAILED_RELEASE_PREMIUM' | 'PENDING_FAILED_RENEW_EXPIRATION_PROTECTION' | 'PENDING_FAILED_RESERVE_PREMIUM' | 'PENDING_FAILED_SUBMIT_FIREHOSE' | 'PENDING_FAILED_TRANSFER_ACK_PREMIUM' | 'PENDING_FAILED_TRANSFER_IN_ACK_PREMIUM' | 'PENDING_FAILED_TRANSFER_IN_PREMIUM' | 'PENDING_FAILED_TRANSFER_PREMIUM' | 'PENDING_FAILED_TRANSFER_SUBMIT_PREMIUM' | 'PENDING_FAILED_UNLOCK_PREMIUM' | 'PENDING_FAILED_UPDATE_API' | 'PENDING_FRAUD_VERIFICATION' | 'PENDING_FRAUD_VERIFIED' | 'PENDING_GET_CONTACTS' | 'PENDING_GET_HOSTS' | 'PENDING_GET_NAME_SERVERS' | 'PENDING_GET_STATUS' | 'PENDING_HOLD_ESCROW' | 'PENDING_HOLD_REDEMPTION' | 'PENDING_LOCK_CLIENT_REMOVE' | 'PENDING_LOCK_DATA_QUALITY' | 'PENDING_LOCK_THEN_HOLD_REDEMPTION' | 'PENDING_PARKING_DETERMINATION' | 'PENDING_PARK_INVALID_WHOIS' | 'PENDING_PARK_INVALID_WHOIS_REMOVAL' | 'PENDING_PURCHASE_PREMIUM' | 'PENDING_RECONCILE' | 'PENDING_RECONCILE_FIREHOSE' | 'PENDING_REDEMPTION' | 'PENDING_REDEMPTION_REPORT' | 'PENDING_REDEMPTION_REPORT_COMPLETE' | 'PENDING_REDEMPTION_REPORT_SUBMITTED' | 'PENDING_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_REDEMPTION_WITHOUT_RECEIPT_MOCK' | 'PENDING_RELEASE_PREMIUM' | 'PENDING_REMOVAL' | 'PENDING_REMOVAL_HELD' | 'PENDING_REMOVAL_PARKED' | 'PENDING_REMOVAL_UNPARK' | 'PENDING_RENEWAL' | 'PENDING_RENEW_EXPIRATION_PROTECTION' | 'PENDING_RENEW_INFINITE' | 'PENDING_RENEW_LOCKED' | 'PENDING_RENEW_WITHOUT_RECEIPT' | 'PENDING_REPORT_REDEMPTION_WITHOUT_RECEIPT' | 'PENDING_RESERVE_PREMIUM' | 'PENDING_RESET_VERIFICATION_ICANN' | 'PENDING_RESPONSE_FIREHOSE' | 'PENDING_RESTORATION' | 'PENDING_RESTORATION_INACTIVE' | 'PENDING_RESTORATION_REDEMPTION_MOCK' | 'PENDING_RETRY_EPP_CREATE' | 'PENDING_RETRY_HELD' | 'PENDING_SEND_AUTH_CODE' | 'PENDING_SETUP' | 'PENDING_SETUP_ABANDON' | 'PENDING_SETUP_AGREEMENT_LANDRUSH' | 'PENDING_SETUP_AGREEMENT_SUNRISE2_A' | 'PENDING_SETUP_AGREEMENT_SUNRISE2_B' | 'PENDING_SETUP_AGREEMENT_SUNRISE2_C' | 'PENDING_SETUP_AUTH' | 'PENDING_SETUP_DNS' | 'PENDING_SETUP_FAILED' | 'PENDING_SETUP_REVIEW' | 'PENDING_SETUP_SUNRISE' | 'PENDING_SETUP_SUNRISE_PRE' | 'PENDING_SETUP_SUNRISE_RESPONSE' | 'PENDING_SUBMIT_FAILURE' | 'PENDING_SUBMIT_FIREHOSE' | 'PENDING_SUBMIT_HOLD_FIREHOSE' | 'PENDING_SUBMIT_HOLD_LANDRUSH' | 'PENDING_SUBMIT_HOLD_SUNRISE' | 'PENDING_SUBMIT_LANDRUSH' | 'PENDING_SUBMIT_RESPONSE_FIREHOSE' | 'PENDING_SUBMIT_RESPONSE_LANDRUSH' | 'PENDING_SUBMIT_RESPONSE_SUNRISE' | 'PENDING_SUBMIT_SUCCESS_FIREHOSE' | 'PENDING_SUBMIT_SUCCESS_LANDRUSH' | 'PENDING_SUBMIT_SUCCESS_SUNRISE' | 'PENDING_SUBMIT_SUNRISE' | 'PENDING_SUBMIT_WAITING_LANDRUSH' | 'PENDING_SUCCESS_PRE_REGISTRATION' | 'PENDING_SUSPENDED_DATA_QUALITY' | 'PENDING_TRANSFER_ACK_PREMIUM' | 'PENDING_TRANSFER_IN' | 'PENDING_TRANSFER_IN_ACK' | 'PENDING_TRANSFER_IN_ACK_PREMIUM' | 'PENDING_TRANSFER_IN_BAD_REGISTRANT' | 'PENDING_TRANSFER_IN_CANCEL' | 'PENDING_TRANSFER_IN_CANCEL_REGISTRY' | 'PENDING_TRANSFER_IN_COMPLETE_ACK' | 'PENDING_TRANSFER_IN_DELETE' | 'PENDING_TRANSFER_IN_LOCK' | 'PENDING_TRANSFER_IN_NACK' | 'PENDING_TRANSFER_IN_NOTIFICATION' | 'PENDING_TRANSFER_IN_PREMIUM' | 'PENDING_TRANSFER_IN_RELEASE' | 'PENDING_TRANSFER_IN_RESPONSE' | 'PENDING_TRANSFER_IN_UNDERAGE' | 'PENDING_TRANSFER_OUT' | 'PENDING_TRANSFER_OUT_ACK' | 'PENDING_TRANSFER_OUT_NACK' | 'PENDING_TRANSFER_OUT_PREMIUM' | 'PENDING_TRANSFER_OUT_UNDERAGE' | 'PENDING_TRANSFER_OUT_VALIDATION' | 'PENDING_TRANSFER_PREMIUM' | 'PENDING_TRANSFER_PREMUIM' | 'PENDING_TRANSFER_SUBMIT_PREMIUM' | 'PENDING_UNLOCK_DATA_QUALITY' | 'PENDING_UNLOCK_PREMIUM' | 'PENDING_UPDATE' | 'PENDING_UPDATED_REGISTRANT_DATA_QUALITY' | 'PENDING_UPDATE_ACCOUNT' | 'PENDING_UPDATE_API' | 'PENDING_UPDATE_API_RESPONSE' | 'PENDING_UPDATE_AUTH' | 'PENDING_UPDATE_CONTACTS' | 'PENDING_UPDATE_CONTACTS_PRIVACY' | 'PENDING_UPDATE_DNS' | 'PENDING_UPDATE_DNS_SECURITY' | 'PENDING_UPDATE_ELIGIBILITY' | 'PENDING_UPDATE_EPP_CONTACTS' | 'PENDING_UPDATE_MEMBERSHIP' | 'PENDING_UPDATE_OWNERSHIP' | 'PENDING_UPDATE_OWNERSHIP_AUTH_AUCTION' | 'PENDING_UPDATE_OWNERSHIP_HELD' | 'PENDING_UPDATE_REGISTRANT' | 'PENDING_UPDATE_REPO' | 'PENDING_VALIDATION_DATA_QUALITY' | 'PENDING_VERIFICATION_FRAUD' | 'PENDING_VERIFICATION_STATUS' | 'PENDING_VERIFY_REGISTRANT_DATA_QUALITY' | 'RESERVED' | 'RESERVED_PREMIUM' | 'REVERTED' | 'SUSPENDED_VERIFICATION_ICANN' | 'TRANSFERRED_OUT' | 'UNLOCKED_ABUSE' | 'UNLOCKED_SUPER' | 'UNPARKED_AND_UNHELD' | 'UPDATED_OWNERSHIP' | 'UPDATED_OWNERSHIP_HELD'>
    
    /**
    * Only include results with `status` value in any of the specified groups
    * @type {Array<'INACTIVE' | 'PRE_REGISTRATION' | 'REDEMPTION' | 'RENEWABLE' | 'VERIFICATION_ICANN' | 'VISIBLE'>}
    * @memberof V1ApiGetDomainsList
    */
    readonly statusGroups?: Array<'INACTIVE' | 'PRE_REGISTRATION' | 'REDEMPTION' | 'RENEWABLE' | 'VERIFICATION_ICANN' | 'VISIBLE'>
    
    /**
    * Maximum number of domains to return
    * @type {number}
    * @memberof V1ApiGetDomainsList
    */
    readonly limit?: number
    
    /**
    * Marker Domain to use as the offset in results
    * @type {string}
    * @memberof V1ApiGetDomainsList
    */
    readonly marker?: string
    
    /**
    * Optional details to be included in the response
    * @type {Array<'authCode' | 'contacts' | 'nameServers'>}
    * @memberof V1ApiGetDomainsList
    */
    readonly includes?: Array<'authCode' | 'contacts' | 'nameServers'>
    
    /**
    * Only include results that have been modified since the specified date
    * @type {string}
    * @memberof V1ApiGetDomainsList
    */
    readonly modifiedDate?: string
    
}

/**
 * Request parameters for getLegalAgreements operation in V1Api.
 * @export
 * @interface V1ApiGetLegalAgreementsRequest
 */
export type V1ApiGetLegalAgreementsRequest = {
    
    /**
    * list of TLDs whose legal agreements are to be retrieved
    * @type {Array<string>}
    * @memberof V1ApiGetLegalAgreements
    */
    readonly tlds: Array<string>
    
    /**
    * Whether or not privacy has been requested
    * @type {boolean}
    * @memberof V1ApiGetLegalAgreements
    */
    readonly privacy: boolean
    
    /**
    * Unique identifier of the Market used to retrieve/translate Legal Agreements
    * @type {string}
    * @memberof V1ApiGetLegalAgreements
    */
    readonly xMarketId?: string
    
    /**
    * Whether or not domain tranfer has been requested
    * @type {boolean}
    * @memberof V1ApiGetLegalAgreements
    */
    readonly forTransfer?: boolean
    
}

/**
 * Request parameters for purchasePrivacyForDomain operation in V1Api.
 * @export
 * @interface V1ApiPurchasePrivacyForDomainRequest
 */
export type V1ApiPurchasePrivacyForDomainRequest = {
    
    /**
    * Domain for which to purchase privacy
    * @type {string}
    * @memberof V1ApiPurchasePrivacyForDomain
    */
    readonly domain: string
    
    /**
    * Shopper ID of the owner of the domain
    * @type {string}
    * @memberof V1ApiPurchasePrivacyForDomain
    */
    readonly xShopperId?: string
    
} & PrivacyPurchase

/**
 * Request parameters for purchaseTransferProcess operation in V1Api.
 * @export
 * @interface V1ApiPurchaseTransferProcessRequest
 */
export type V1ApiPurchaseTransferProcessRequest = {
    
    /**
    * Domain to transfer in
    * @type {string}
    * @memberof V1ApiPurchaseTransferProcess
    */
    readonly domain: string
    
    /**
    * The Shopper to whom the domain should be transfered
    * @type {string}
    * @memberof V1ApiPurchaseTransferProcess
    */
    readonly xShopperId?: string
    
} & DomainTransferIn

/**
 * Request parameters for renewDomain operation in V1Api.
 * @export
 * @interface V1ApiRenewDomainRequest
 */
export type V1ApiRenewDomainRequest = {
    
    /**
    * Domain to renew
    * @type {string}
    * @memberof V1ApiRenewDomain
    */
    readonly domain: string
    
    /**
    * Shopper for whom Domain is to be renewed. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\'re a Reseller, but purchased a Domain via http://www.godaddy.com
    * @type {string}
    * @memberof V1ApiRenewDomain
    */
    readonly xShopperId?: string
    
} & DomainRenew

/**
 * Request parameters for replaceDnsRecords operation in V1Api.
 * @export
 * @interface V1ApiReplaceDnsRecordsRequest
 */
export type V1ApiReplaceDnsRecordsRequest = {
    /**
    * Domain whose DNS Records are to be replaced
    * @type {string}
    * @memberof V1ApiReplaceDnsRecords
    */
    readonly domain: string
    /**
    * DNS Records to replace whatever currently exists
    * @type {Array<DNSRecord>}
    * @memberof V1ApiReplaceDnsRecords
    */
    readonly requestBody: Array<DNSRecord>
    /**
    * Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\'re a Reseller, but purchased a Domain via http://www.godaddy.com
    * @type {string}
    * @memberof V1ApiReplaceDnsRecords
    */
    readonly xShopperId?: string
}

/**
 * Request parameters for replaceDnsRecordsType operation in V1Api.
 * @export
 * @interface V1ApiReplaceDnsRecordsTypeRequest
 */
export type V1ApiReplaceDnsRecordsTypeRequest = {
    /**
    * Domain whose DNS Records are to be replaced
    * @type {string}
    * @memberof V1ApiReplaceDnsRecordsType
    */
    readonly domain: string
    /**
    * DNS Record Type for which DNS Records are to be replaced
    * @type {'A' | 'AAAA' | 'CNAME' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'TXT'}
    * @memberof V1ApiReplaceDnsRecordsType
    */
    readonly type: 'A' | 'AAAA' | 'CNAME' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'TXT'
    /**
    * DNS Records to replace whatever currently exists
    * @type {Array<DNSRecordCreateType>}
    * @memberof V1ApiReplaceDnsRecordsType
    */
    readonly requestBody: Array<DNSRecordCreateType>
    /**
    * Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\'re a Reseller, but purchased a Domain via http://www.godaddy.com
    * @type {string}
    * @memberof V1ApiReplaceDnsRecordsType
    */
    readonly xShopperId?: string
}

/**
 * Request parameters for replaceDnsRecordsType_1 operation in V1Api.
 * @export
 * @interface V1ApiReplaceDnsRecordsType0Request
 */
export type V1ApiReplaceDnsRecordsType0Request = {
    /**
    * Domain whose DNS Records are to be replaced
    * @type {string}
    * @memberof V1ApiReplaceDnsRecordsType0
    */
    readonly domain: string
    /**
    * DNS Record Type for which DNS Records are to be replaced
    * @type {'A' | 'AAAA' | 'CNAME' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'TXT'}
    * @memberof V1ApiReplaceDnsRecordsType0
    */
    readonly type: 'A' | 'AAAA' | 'CNAME' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'TXT'
    /**
    * DNS Record Name for which DNS Records are to be replaced
    * @type {string}
    * @memberof V1ApiReplaceDnsRecordsType0
    */
    readonly name: string
    /**
    * DNS Records to replace whatever currently exists
    * @type {Array<DNSRecordCreateTypeName>}
    * @memberof V1ApiReplaceDnsRecordsType0
    */
    readonly requestBody: Array<DNSRecordCreateTypeName>
    /**
    * Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\'re a Reseller, but purchased a Domain via http://www.godaddy.com
    * @type {string}
    * @memberof V1ApiReplaceDnsRecordsType0
    */
    readonly xShopperId?: string
}

/**
 * Request parameters for resendContactEmailVerification operation in V1Api.
 * @export
 * @interface V1ApiResendContactEmailVerificationRequest
 */
export type V1ApiResendContactEmailVerificationRequest = {
    
    /**
    * Domain whose Contact E-mail should be verified.
    * @type {string}
    * @memberof V1ApiResendContactEmailVerification
    */
    readonly domain: string
    
    /**
    * Shopper for whom domain contact e-mail should be verified. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\'re a Reseller, but purchased a Domain via http://www.godaddy.com
    * @type {string}
    * @memberof V1ApiResendContactEmailVerification
    */
    readonly xShopperId?: string
    
}

/**
 * Request parameters for suggestAlternateDomains operation in V1Api.
 * @export
 * @interface V1ApiSuggestAlternateDomainsRequest
 */
export type V1ApiSuggestAlternateDomainsRequest = {
    
    /**
    * Shopper ID for which the suggestions are being generated
    * @type {string}
    * @memberof V1ApiSuggestAlternateDomains
    */
    readonly xShopperId?: string
    
    /**
    * Domain name or set of keywords for which alternative domain names will be suggested
    * @type {string}
    * @memberof V1ApiSuggestAlternateDomains
    */
    readonly query?: string
    
    /**
    * Two-letter ISO country code to be used as a hint for target region<br/><br/> NOTE: These are sample values, there are many <a href=\"http://www.iso.org/iso/country_codes.htm\">more</a>
    * @type {'AC' | 'AD' | 'AE' | 'AF' | 'AG' | 'AI' | 'AL' | 'AM' | 'AO' | 'AQ' | 'AR' | 'AS' | 'AT' | 'AU' | 'AW' | 'AX' | 'AZ' | 'BA' | 'BB' | 'BD' | 'BE' | 'BF' | 'BG' | 'BH' | 'BI' | 'BJ' | 'BM' | 'BN' | 'BO' | 'BQ' | 'BR' | 'BS' | 'BT' | 'BV' | 'BW' | 'BY' | 'BZ' | 'CA' | 'CC' | 'CD' | 'CF' | 'CG' | 'CH' | 'CI' | 'CK' | 'CL' | 'CM' | 'CN' | 'CO' | 'CR' | 'CV' | 'CW' | 'CX' | 'CY' | 'CZ' | 'DE' | 'DJ' | 'DK' | 'DM' | 'DO' | 'DZ' | 'EC' | 'EE' | 'EG' | 'EH' | 'ER' | 'ES' | 'ET' | 'FI' | 'FJ' | 'FK' | 'FM' | 'FO' | 'FR' | 'GA' | 'GB' | 'GD' | 'GE' | 'GF' | 'GG' | 'GH' | 'GI' | 'GL' | 'GM' | 'GN' | 'GP' | 'GQ' | 'GR' | 'GS' | 'GT' | 'GU' | 'GW' | 'GY' | 'HK' | 'HM' | 'HN' | 'HR' | 'HT' | 'HU' | 'ID' | 'IE' | 'IL' | 'IM' | 'IN' | 'IO' | 'IQ' | 'IS' | 'IT' | 'JE' | 'JM' | 'JO' | 'JP' | 'KE' | 'KG' | 'KH' | 'KI' | 'KM' | 'KN' | 'KR' | 'KV' | 'KW' | 'KY' | 'KZ' | 'LA' | 'LB' | 'LC' | 'LI' | 'LK' | 'LR' | 'LS' | 'LT' | 'LU' | 'LV' | 'LY' | 'MA' | 'MC' | 'MD' | 'ME' | 'MG' | 'MH' | 'MK' | 'ML' | 'MM' | 'MN' | 'MO' | 'MP' | 'MQ' | 'MR' | 'MS' | 'MT' | 'MU' | 'MV' | 'MW' | 'MX' | 'MY' | 'MZ' | 'NA' | 'NC' | 'NE' | 'NF' | 'NG' | 'NI' | 'NL' | 'false' | 'NP' | 'NR' | 'NU' | 'NZ' | 'OM' | 'PA' | 'PE' | 'PF' | 'PG' | 'PH' | 'PK' | 'PL' | 'PM' | 'PN' | 'PR' | 'PS' | 'PT' | 'PW' | 'PY' | 'QA' | 'RE' | 'RO' | 'RS' | 'RU' | 'RW' | 'SA' | 'SB' | 'SC' | 'SE' | 'SG' | 'SH' | 'SI' | 'SJ' | 'SK' | 'SL' | 'SM' | 'SN' | 'SO' | 'SR' | 'ST' | 'SV' | 'SX' | 'SZ' | 'TC' | 'TD' | 'TF' | 'TG' | 'TH' | 'TJ' | 'TK' | 'TL' | 'TM' | 'TN' | 'TO' | 'TP' | 'TR' | 'TT' | 'TV' | 'TW' | 'TZ' | 'UA' | 'UG' | 'UM' | 'US' | 'UY' | 'UZ' | 'VA' | 'VC' | 'VE' | 'VG' | 'VI' | 'VN' | 'VU' | 'WF' | 'WS' | 'YE' | 'YT' | 'ZA' | 'ZM' | 'ZW'}
    * @memberof V1ApiSuggestAlternateDomains
    */
    readonly country?: 'AC' | 'AD' | 'AE' | 'AF' | 'AG' | 'AI' | 'AL' | 'AM' | 'AO' | 'AQ' | 'AR' | 'AS' | 'AT' | 'AU' | 'AW' | 'AX' | 'AZ' | 'BA' | 'BB' | 'BD' | 'BE' | 'BF' | 'BG' | 'BH' | 'BI' | 'BJ' | 'BM' | 'BN' | 'BO' | 'BQ' | 'BR' | 'BS' | 'BT' | 'BV' | 'BW' | 'BY' | 'BZ' | 'CA' | 'CC' | 'CD' | 'CF' | 'CG' | 'CH' | 'CI' | 'CK' | 'CL' | 'CM' | 'CN' | 'CO' | 'CR' | 'CV' | 'CW' | 'CX' | 'CY' | 'CZ' | 'DE' | 'DJ' | 'DK' | 'DM' | 'DO' | 'DZ' | 'EC' | 'EE' | 'EG' | 'EH' | 'ER' | 'ES' | 'ET' | 'FI' | 'FJ' | 'FK' | 'FM' | 'FO' | 'FR' | 'GA' | 'GB' | 'GD' | 'GE' | 'GF' | 'GG' | 'GH' | 'GI' | 'GL' | 'GM' | 'GN' | 'GP' | 'GQ' | 'GR' | 'GS' | 'GT' | 'GU' | 'GW' | 'GY' | 'HK' | 'HM' | 'HN' | 'HR' | 'HT' | 'HU' | 'ID' | 'IE' | 'IL' | 'IM' | 'IN' | 'IO' | 'IQ' | 'IS' | 'IT' | 'JE' | 'JM' | 'JO' | 'JP' | 'KE' | 'KG' | 'KH' | 'KI' | 'KM' | 'KN' | 'KR' | 'KV' | 'KW' | 'KY' | 'KZ' | 'LA' | 'LB' | 'LC' | 'LI' | 'LK' | 'LR' | 'LS' | 'LT' | 'LU' | 'LV' | 'LY' | 'MA' | 'MC' | 'MD' | 'ME' | 'MG' | 'MH' | 'MK' | 'ML' | 'MM' | 'MN' | 'MO' | 'MP' | 'MQ' | 'MR' | 'MS' | 'MT' | 'MU' | 'MV' | 'MW' | 'MX' | 'MY' | 'MZ' | 'NA' | 'NC' | 'NE' | 'NF' | 'NG' | 'NI' | 'NL' | 'false' | 'NP' | 'NR' | 'NU' | 'NZ' | 'OM' | 'PA' | 'PE' | 'PF' | 'PG' | 'PH' | 'PK' | 'PL' | 'PM' | 'PN' | 'PR' | 'PS' | 'PT' | 'PW' | 'PY' | 'QA' | 'RE' | 'RO' | 'RS' | 'RU' | 'RW' | 'SA' | 'SB' | 'SC' | 'SE' | 'SG' | 'SH' | 'SI' | 'SJ' | 'SK' | 'SL' | 'SM' | 'SN' | 'SO' | 'SR' | 'ST' | 'SV' | 'SX' | 'SZ' | 'TC' | 'TD' | 'TF' | 'TG' | 'TH' | 'TJ' | 'TK' | 'TL' | 'TM' | 'TN' | 'TO' | 'TP' | 'TR' | 'TT' | 'TV' | 'TW' | 'TZ' | 'UA' | 'UG' | 'UM' | 'US' | 'UY' | 'UZ' | 'VA' | 'VC' | 'VE' | 'VG' | 'VI' | 'VN' | 'VU' | 'WF' | 'WS' | 'YE' | 'YT' | 'ZA' | 'ZM' | 'ZW'
    
    /**
    * Name of city to be used as a hint for target region
    * @type {string}
    * @memberof V1ApiSuggestAlternateDomains
    */
    readonly city?: string
    
    /**
    * Sources to be queried<br/><br/><ul> <li><strong>CC_TLD</strong> - Varies the TLD using Country Codes</li> <li><strong>EXTENSION</strong> - Varies the TLD</li> <li><strong>KEYWORD_SPIN</strong> - Identifies keywords and then rotates each one</li> <li><strong>PREMIUM</strong> - Includes variations with premium prices</li></ul>
    * @type {Array<'CC_TLD' | 'EXTENSION' | 'KEYWORD_SPIN' | 'PREMIUM' | 'cctld' | 'extension' | 'keywordspin' | 'premium'>}
    * @memberof V1ApiSuggestAlternateDomains
    */
    readonly sources?: Array<'CC_TLD' | 'EXTENSION' | 'KEYWORD_SPIN' | 'PREMIUM' | 'cctld' | 'extension' | 'keywordspin' | 'premium'>
    
    /**
    * Top-level domains to be included in suggestions<br/><br/> NOTE: These are sample values, there are many <a href=\"http://www.godaddy.com/tlds/gtld.aspx#domain_search_form\">more</a>
    * @type {Array<string>}
    * @memberof V1ApiSuggestAlternateDomains
    */
    readonly tlds?: Array<string>
    
    /**
    * Maximum length of second-level domain
    * @type {number}
    * @memberof V1ApiSuggestAlternateDomains
    */
    readonly lengthMax?: number
    
    /**
    * Minimum length of second-level domain
    * @type {number}
    * @memberof V1ApiSuggestAlternateDomains
    */
    readonly lengthMin?: number
    
    /**
    * Maximum number of suggestions to return
    * @type {number}
    * @memberof V1ApiSuggestAlternateDomains
    */
    readonly limit?: number
    
    /**
    * Maximum amount of time, in milliseconds, to wait for responses If elapses, return the results compiled up to that point
    * @type {number}
    * @memberof V1ApiSuggestAlternateDomains
    */
    readonly waitMs?: number
    
}

/**
 * Request parameters for updateDomainContacts operation in V1Api.
 * @export
 * @interface V1ApiUpdateDomainContactsRequest
 */
export type V1ApiUpdateDomainContactsRequest = {
    
    /**
    * Domain whose Contacts are to be updated.
    * @type {string}
    * @memberof V1ApiUpdateDomainContacts
    */
    readonly domain: string
    
    /**
    * Shopper for whom domain contacts are to be updated. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\'re a Reseller, but purchased a Domain via http://www.godaddy.com
    * @type {string}
    * @memberof V1ApiUpdateDomainContacts
    */
    readonly xShopperId?: string
    
} & DomainContacts

/**
 * Request parameters for updateDomainDetails operation in V1Api.
 * @export
 * @interface V1ApiUpdateDomainDetailsRequest
 */
export type V1ApiUpdateDomainDetailsRequest = {
    
    /**
    * Domain whose details are to be updated
    * @type {string}
    * @memberof V1ApiUpdateDomainDetails
    */
    readonly domain: string
    
    /**
    * Shopper for whom Domain is to be updated. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you\'re a Reseller, but purchased a Domain via http://www.godaddy.com
    * @type {string}
    * @memberof V1ApiUpdateDomainDetails
    */
    readonly xShopperId?: string
    
} & DomainUpdate

/**
 * Request parameters for validateDomainContacts operation in V1Api.
 * @export
 * @interface V1ApiValidateDomainContactsRequest
 */
export type V1ApiValidateDomainContactsRequest = {
    
    /**
    * PrivateLabelId to operate as, if different from JWT
    * @type {number}
    * @memberof V1ApiValidateDomainContacts
    */
    readonly xPrivateLabelId?: number
    
    /**
    * MarketId in which the request is being made, and for which responses should be localized
    * @type {string}
    * @memberof V1ApiValidateDomainContacts
    */
    readonly marketId?: string
    
} & DomainsContactsBulk

/**
 * Request parameters for validateDomainPurchase operation in V1Api.
 * @export
 * @interface V1ApiValidateDomainPurchaseRequest
 */
export type V1ApiValidateDomainPurchaseRequest = {
    
} & DomainPurchase

/**
 * V1ApiGenerated - object-oriented interface
 * @export
 * @class V1ApiGenerated
 * @extends {BaseAPI}
 */
export class V1ApiGenerated extends BaseAPI {
    /**
     * 
     * @summary Add the specified DNS Records to the specified Domain
     * @param {V1ApiAddDnsRecordsToDomainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public addDnsRecordsToDomain(requestParameters: V1ApiAddDnsRecordsToDomainRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).addDnsRecordsToDomain(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel a purchased domain
     * @param {V1ApiCancelDomainPurchaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public cancelDomainPurchase(requestParameters: V1ApiCancelDomainPurchaseRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).cancelDomainPurchase(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit a privacy cancellation request for the given domain
     * @param {V1ApiCancelPrivacyRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public cancelPrivacyRequest(requestParameters: V1ApiCancelPrivacyRequestRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).cancelPrivacyRequest(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Determine whether or not the specified domain is available for purchase
     * @param {V1ApiCheckDomainAvailabilityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public checkDomainAvailability(requestParameters: V1ApiCheckDomainAvailabilityRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).checkDomainAvailability(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Determine whether or not the specified domains are available for purchase
     * @param {V1ApiCheckDomainAvailabilityPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public checkDomainAvailabilityPost(requestParameters: V1ApiCheckDomainAvailabilityPostRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).checkDomainAvailabilityPost(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase and register the specified Domain
     * @param {V1ApiCreateDomainPurchaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public createDomainPurchase(requestParameters: V1ApiCreateDomainPurchaseRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).createDomainPurchase(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all DNS Records for the specified Domain with the specified Type and Name
     * @param {V1ApiDeleteAllDnsRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public deleteAllDnsRecords(requestParameters: V1ApiDeleteAllDnsRecordsRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).deleteAllDnsRecords(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve DNS Records for the specified Domain, optionally with the specified Type and/or Name
     * @param {V1ApiGetDnsRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public getDnsRecords(requestParameters: V1ApiGetDnsRecordsRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).getDnsRecords(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve details for the specified Domain
     * @param {V1ApiGetDomainDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public getDomainDetails(requestParameters: V1ApiGetDomainDetailsRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).getDomainDetails(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the schema to be submitted when registering a Domain for the specified TLD
     * @param {V1ApiGetDomainSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public getDomainSchema(requestParameters: V1ApiGetDomainSchemaRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).getDomainSchema(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of Domains for the specified Shopper
     * @param {V1ApiGetDomainsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public getDomainsList(requestParameters: V1ApiGetDomainsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).getDomainsList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the legal agreement(s) required to purchase the specified TLD and add-ons
     * @param {V1ApiGetLegalAgreementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public getLegalAgreements(requestParameters: V1ApiGetLegalAgreementsRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).getLegalAgreements(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a list of TLDs supported and enabled for sale
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public getTldsList(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).getTldsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase privacy for a specified domain
     * @param {V1ApiPurchasePrivacyForDomainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public purchasePrivacyForDomain(requestParameters: V1ApiPurchasePrivacyForDomainRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).purchasePrivacyForDomain(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase and start or restart transfer process
     * @param {V1ApiPurchaseTransferProcessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public purchaseTransferProcess(requestParameters: V1ApiPurchaseTransferProcessRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).purchaseTransferProcess(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Renew the specified Domain
     * @param {V1ApiRenewDomainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public renewDomain(requestParameters: V1ApiRenewDomainRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).renewDomain(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replace all DNS Records for the specified Domain
     * @param {V1ApiReplaceDnsRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public replaceDnsRecords(requestParameters: V1ApiReplaceDnsRecordsRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).replaceDnsRecords(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replace all DNS Records for the specified Domain with the specified Type
     * @param {V1ApiReplaceDnsRecordsTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public replaceDnsRecordsType(requestParameters: V1ApiReplaceDnsRecordsTypeRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).replaceDnsRecordsType(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replace all DNS Records for the specified Domain with the specified Type and Name
     * @param {V1ApiReplaceDnsRecordsType0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public replaceDnsRecordsType_1(requestParameters: V1ApiReplaceDnsRecordsType0Request, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).replaceDnsRecordsType_1(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Re-send Contact E-mail Verification for specified Domain
     * @param {V1ApiResendContactEmailVerificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public resendContactEmailVerification(requestParameters: V1ApiResendContactEmailVerificationRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).resendContactEmailVerification(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Suggest alternate Domain names based on a seed Domain, a set of keywords, or the shopper\'s purchase history
     * @param {V1ApiSuggestAlternateDomainsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public suggestAlternateDomains(requestParameters: V1ApiSuggestAlternateDomainsRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).suggestAlternateDomains(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update domain
     * @param {V1ApiUpdateDomainContactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public updateDomainContacts(requestParameters: V1ApiUpdateDomainContactsRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).updateDomainContacts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update details for the specified Domain
     * @param {V1ApiUpdateDomainDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public updateDomainDetails(requestParameters: V1ApiUpdateDomainDetailsRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).updateDomainDetails(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All contacts specified in request will be validated against all domains specifed in \"domains\". As an alternative, you can also pass in tlds, with the exception of `uk`, which requires full domain names
     * @summary Validate the request body using the Domain Contact Validation Schema for specified domains.
     * @param {V1ApiValidateDomainContactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public validateDomainContacts(requestParameters: V1ApiValidateDomainContactsRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).validateDomainContacts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate the request body using the Domain Purchase Schema for the specified TLD
     * @param {V1ApiValidateDomainPurchaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiGenerated
     */
    public validateDomainPurchase(requestParameters: V1ApiValidateDomainPurchaseRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).validateDomainPurchase(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
