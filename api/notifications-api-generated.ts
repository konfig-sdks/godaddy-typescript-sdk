/* tslint:disable */
/* eslint-disable */
/*


All the help and tools you need to grow online: Websites, Domains, Digital and Social Marketing - plus GoDaddy Guides with you every step of the way.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { DomainNotification } from '../models';
// @ts-ignore
import { ErrorLimit } from '../models';
// @ts-ignore
import { JsonSchema } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Acknowledge a domain notification
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} notificationId The notification ID to acknowledge
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeDomainNotification: async (customerId: string, notificationId: string, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('acknowledgeDomainNotification', 'customerId', customerId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('acknowledgeDomainNotification', 'notificationId', notificationId)
            const localVarPath = `/v2/customers/{customerId}/domains/notifications/{notificationId}/acknowledge`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId !== undefined ? notificationId : `-notificationId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/notifications/{notificationId}/acknowledge',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the next domain notification
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextDomain: async (customerId: string, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getNextDomain', 'customerId', customerId)
            const localVarPath = `/v2/customers/{customerId}/domains/notifications`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/notifications',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the schema for the notification data for the specified notification type
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {'AUTO_RENEWAL' | 'BACKORDER' | 'BACKORDER_PURCHASE' | 'EXPIRY' | 'PREMIUM' | 'PRIVACY_PURCHASE' | 'REDEEM' | 'REGISTER' | 'RENEW' | 'TRADE' | 'TRANSFER'} type The notification type whose schema should be retrieved
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema: async (customerId: string, type: 'AUTO_RENEWAL' | 'BACKORDER' | 'BACKORDER_PURCHASE' | 'EXPIRY' | 'PREMIUM' | 'PRIVACY_PURCHASE' | 'REDEEM' | 'REGISTER' | 'RENEW' | 'TRADE' | 'TRANSFER', xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getSchema', 'customerId', customerId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getSchema', 'type', type)
            const localVarPath = `/v2/customers/{customerId}/domains/notifications/schemas/{type}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type !== undefined ? type : `-type-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/notifications/schemas/{type}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of notification types that are opted in
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOptedInTypes: async (customerId: string, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('listOptedInTypes', 'customerId', customerId)
            const localVarPath = `/v2/customers/{customerId}/domains/notifications/optIn`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/notifications/optIn',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Opt in to recieve notifications for the submitted notification types
         * @param {string} customerId The Customer identifier&lt;br/&gt; Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\&#39;re operating on behalf of; otherwise use your shopper id.
         * @param {Array<'AUTH_CODE_PURCHASE' | 'AUTH_CODE_REGENERATE' | 'AUTO_RENEWAL' | 'BACKORDER' | 'BACKORDER_PURCHASE' | 'BACKORDER_DELETE' | 'BACKORDER_UPDATE' | 'CONTACT_CREATE' | 'CONTACT_DELETE' | 'CONTACT_UPDATE' | 'DNS_VERIFICATION' | 'DNSSEC_CREATE' | 'DNSSEC_DELETE' | 'DOMAIN_DELETE' | 'DOMAIN_UPDATE' | 'DOMAIN_UPDATE_CONTACTS' | 'DOMAIN_UPDATE_NAME_SERVERS' | 'EXPIRY' | 'HOST_CREATE' | 'HOST_DELETE' | 'ICANN_VERIFICATION' | 'MIGRATE' | 'MIGRATE_IN' | 'PREMIUM' | 'PRIVACY_PURCHASE' | 'PRIVACY_DELETE' | 'REDEEM' | 'REGISTER' | 'RENEW' | 'RENEW_UNDO' | 'TRADE' | 'TRADE_CANCEL' | 'TRADE_PURCHASE' | 'TRADE_PURCHASE_AUTH_TEXT_MESSAGE' | 'TRADE_RESEND_AUTH_EMAIL' | 'TRANSFER' | 'TRANSFER_IN' | 'TRANSFER_IN_ACCEPT' | 'TRANSFER_IN_CANCEL' | 'TRANSFER_IN_RESTART' | 'TRANSFER_IN_RETRY' | 'TRANSFER_OUT' | 'TRANSFER_OUT_ACCEPT' | 'TRANSFER_OUT_REJECT' | 'TRANSFER_OUT_REQUESTED' | 'TRANSIT'>} types The notification types that should be opted in
         * @param {string} [xRequestId] A client provided identifier for tracking this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optInNotifications: async (customerId: string, types: Array<'AUTH_CODE_PURCHASE' | 'AUTH_CODE_REGENERATE' | 'AUTO_RENEWAL' | 'BACKORDER' | 'BACKORDER_PURCHASE' | 'BACKORDER_DELETE' | 'BACKORDER_UPDATE' | 'CONTACT_CREATE' | 'CONTACT_DELETE' | 'CONTACT_UPDATE' | 'DNS_VERIFICATION' | 'DNSSEC_CREATE' | 'DNSSEC_DELETE' | 'DOMAIN_DELETE' | 'DOMAIN_UPDATE' | 'DOMAIN_UPDATE_CONTACTS' | 'DOMAIN_UPDATE_NAME_SERVERS' | 'EXPIRY' | 'HOST_CREATE' | 'HOST_DELETE' | 'ICANN_VERIFICATION' | 'MIGRATE' | 'MIGRATE_IN' | 'PREMIUM' | 'PRIVACY_PURCHASE' | 'PRIVACY_DELETE' | 'REDEEM' | 'REGISTER' | 'RENEW' | 'RENEW_UNDO' | 'TRADE' | 'TRADE_CANCEL' | 'TRADE_PURCHASE' | 'TRADE_PURCHASE_AUTH_TEXT_MESSAGE' | 'TRADE_RESEND_AUTH_EMAIL' | 'TRANSFER' | 'TRANSFER_IN' | 'TRANSFER_IN_ACCEPT' | 'TRANSFER_IN_CANCEL' | 'TRANSFER_IN_RESTART' | 'TRANSFER_IN_RETRY' | 'TRANSFER_OUT' | 'TRANSFER_OUT_ACCEPT' | 'TRANSFER_OUT_REJECT' | 'TRANSFER_OUT_REQUESTED' | 'TRANSIT'>, xRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('optInNotifications', 'customerId', customerId)
            // verify required parameter 'types' is not null or undefined
            assertParamExists('optInNotifications', 'types', types)
            const localVarPath = `/v2/customers/{customerId}/domains/notifications/optIn`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId !== undefined ? customerId : `-customerId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiKey", keyParamName: "apiKey", configuration })
            // authentication apiSecret required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "apiSecret", keyParamName: "apiSecret", configuration })
            if (types) {
                localVarQueryParameter['types'] = types.join(COLLECTION_FORMATS.csv);
            }

            if (xRequestId != null) {
                localVarHeaderParameter['X-Request-Id'] = String(xRequestId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/customers/{customerId}/domains/notifications/optIn',
                httpMethod: 'PUT'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Acknowledge a domain notification
         * @param {NotificationsApiAcknowledgeDomainNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acknowledgeDomainNotification(requestParameters: NotificationsApiAcknowledgeDomainNotificationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acknowledgeDomainNotification(requestParameters.customerId, requestParameters.notificationId, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the next domain notification
         * @param {NotificationsApiGetNextDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNextDomain(requestParameters: NotificationsApiGetNextDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainNotification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNextDomain(requestParameters.customerId, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the schema for the notification data for the specified notification type
         * @param {NotificationsApiGetSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchema(requestParameters: NotificationsApiGetSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchema(requestParameters.customerId, requestParameters.type, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of notification types that are opted in
         * @param {NotificationsApiListOptedInTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOptedInTypes(requestParameters: NotificationsApiListOptedInTypesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainNotification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOptedInTypes(requestParameters.customerId, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Opt in to recieve notifications for the submitted notification types
         * @param {NotificationsApiOptInNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optInNotifications(requestParameters: NotificationsApiOptInNotificationsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optInNotifications(requestParameters.customerId, requestParameters.types, requestParameters.xRequestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Acknowledge a domain notification
         * @param {NotificationsApiAcknowledgeDomainNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeDomainNotification(requestParameters: NotificationsApiAcknowledgeDomainNotificationRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.acknowledgeDomainNotification(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the next domain notification
         * @param {NotificationsApiGetNextDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextDomain(requestParameters: NotificationsApiGetNextDomainRequest, options?: AxiosRequestConfig): AxiosPromise<DomainNotification> {
            return localVarFp.getNextDomain(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the schema for the notification data for the specified notification type
         * @param {NotificationsApiGetSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(requestParameters: NotificationsApiGetSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<JsonSchema> {
            return localVarFp.getSchema(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of notification types that are opted in
         * @param {NotificationsApiListOptedInTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOptedInTypes(requestParameters: NotificationsApiListOptedInTypesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DomainNotification>> {
            return localVarFp.listOptedInTypes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Opt in to recieve notifications for the submitted notification types
         * @param {NotificationsApiOptInNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optInNotifications(requestParameters: NotificationsApiOptInNotificationsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.optInNotifications(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for acknowledgeDomainNotification operation in NotificationsApi.
 * @export
 * @interface NotificationsApiAcknowledgeDomainNotificationRequest
 */
export type NotificationsApiAcknowledgeDomainNotificationRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof NotificationsApiAcknowledgeDomainNotification
    */
    readonly customerId: string
    
    /**
    * The notification ID to acknowledge
    * @type {string}
    * @memberof NotificationsApiAcknowledgeDomainNotification
    */
    readonly notificationId: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof NotificationsApiAcknowledgeDomainNotification
    */
    readonly xRequestId?: string
    
}

/**
 * Request parameters for getNextDomain operation in NotificationsApi.
 * @export
 * @interface NotificationsApiGetNextDomainRequest
 */
export type NotificationsApiGetNextDomainRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof NotificationsApiGetNextDomain
    */
    readonly customerId: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof NotificationsApiGetNextDomain
    */
    readonly xRequestId?: string
    
}

/**
 * Request parameters for getSchema operation in NotificationsApi.
 * @export
 * @interface NotificationsApiGetSchemaRequest
 */
export type NotificationsApiGetSchemaRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof NotificationsApiGetSchema
    */
    readonly customerId: string
    
    /**
    * The notification type whose schema should be retrieved
    * @type {'AUTO_RENEWAL' | 'BACKORDER' | 'BACKORDER_PURCHASE' | 'EXPIRY' | 'PREMIUM' | 'PRIVACY_PURCHASE' | 'REDEEM' | 'REGISTER' | 'RENEW' | 'TRADE' | 'TRANSFER'}
    * @memberof NotificationsApiGetSchema
    */
    readonly type: 'AUTO_RENEWAL' | 'BACKORDER' | 'BACKORDER_PURCHASE' | 'EXPIRY' | 'PREMIUM' | 'PRIVACY_PURCHASE' | 'REDEEM' | 'REGISTER' | 'RENEW' | 'TRADE' | 'TRANSFER'
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof NotificationsApiGetSchema
    */
    readonly xRequestId?: string
    
}

/**
 * Request parameters for listOptedInTypes operation in NotificationsApi.
 * @export
 * @interface NotificationsApiListOptedInTypesRequest
 */
export type NotificationsApiListOptedInTypesRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof NotificationsApiListOptedInTypes
    */
    readonly customerId: string
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof NotificationsApiListOptedInTypes
    */
    readonly xRequestId?: string
    
}

/**
 * Request parameters for optInNotifications operation in NotificationsApi.
 * @export
 * @interface NotificationsApiOptInNotificationsRequest
 */
export type NotificationsApiOptInNotificationsRequest = {
    
    /**
    * The Customer identifier<br/> Note: For API Resellers, performing actions on behalf of your customers, you need to specify the Subaccount you\'re operating on behalf of; otherwise use your shopper id.
    * @type {string}
    * @memberof NotificationsApiOptInNotifications
    */
    readonly customerId: string
    
    /**
    * The notification types that should be opted in
    * @type {Array<'AUTH_CODE_PURCHASE' | 'AUTH_CODE_REGENERATE' | 'AUTO_RENEWAL' | 'BACKORDER' | 'BACKORDER_PURCHASE' | 'BACKORDER_DELETE' | 'BACKORDER_UPDATE' | 'CONTACT_CREATE' | 'CONTACT_DELETE' | 'CONTACT_UPDATE' | 'DNS_VERIFICATION' | 'DNSSEC_CREATE' | 'DNSSEC_DELETE' | 'DOMAIN_DELETE' | 'DOMAIN_UPDATE' | 'DOMAIN_UPDATE_CONTACTS' | 'DOMAIN_UPDATE_NAME_SERVERS' | 'EXPIRY' | 'HOST_CREATE' | 'HOST_DELETE' | 'ICANN_VERIFICATION' | 'MIGRATE' | 'MIGRATE_IN' | 'PREMIUM' | 'PRIVACY_PURCHASE' | 'PRIVACY_DELETE' | 'REDEEM' | 'REGISTER' | 'RENEW' | 'RENEW_UNDO' | 'TRADE' | 'TRADE_CANCEL' | 'TRADE_PURCHASE' | 'TRADE_PURCHASE_AUTH_TEXT_MESSAGE' | 'TRADE_RESEND_AUTH_EMAIL' | 'TRANSFER' | 'TRANSFER_IN' | 'TRANSFER_IN_ACCEPT' | 'TRANSFER_IN_CANCEL' | 'TRANSFER_IN_RESTART' | 'TRANSFER_IN_RETRY' | 'TRANSFER_OUT' | 'TRANSFER_OUT_ACCEPT' | 'TRANSFER_OUT_REJECT' | 'TRANSFER_OUT_REQUESTED' | 'TRANSIT'>}
    * @memberof NotificationsApiOptInNotifications
    */
    readonly types: Array<'AUTH_CODE_PURCHASE' | 'AUTH_CODE_REGENERATE' | 'AUTO_RENEWAL' | 'BACKORDER' | 'BACKORDER_PURCHASE' | 'BACKORDER_DELETE' | 'BACKORDER_UPDATE' | 'CONTACT_CREATE' | 'CONTACT_DELETE' | 'CONTACT_UPDATE' | 'DNS_VERIFICATION' | 'DNSSEC_CREATE' | 'DNSSEC_DELETE' | 'DOMAIN_DELETE' | 'DOMAIN_UPDATE' | 'DOMAIN_UPDATE_CONTACTS' | 'DOMAIN_UPDATE_NAME_SERVERS' | 'EXPIRY' | 'HOST_CREATE' | 'HOST_DELETE' | 'ICANN_VERIFICATION' | 'MIGRATE' | 'MIGRATE_IN' | 'PREMIUM' | 'PRIVACY_PURCHASE' | 'PRIVACY_DELETE' | 'REDEEM' | 'REGISTER' | 'RENEW' | 'RENEW_UNDO' | 'TRADE' | 'TRADE_CANCEL' | 'TRADE_PURCHASE' | 'TRADE_PURCHASE_AUTH_TEXT_MESSAGE' | 'TRADE_RESEND_AUTH_EMAIL' | 'TRANSFER' | 'TRANSFER_IN' | 'TRANSFER_IN_ACCEPT' | 'TRANSFER_IN_CANCEL' | 'TRANSFER_IN_RESTART' | 'TRANSFER_IN_RETRY' | 'TRANSFER_OUT' | 'TRANSFER_OUT_ACCEPT' | 'TRANSFER_OUT_REJECT' | 'TRANSFER_OUT_REQUESTED' | 'TRANSIT'>
    
    /**
    * A client provided identifier for tracking this request.
    * @type {string}
    * @memberof NotificationsApiOptInNotifications
    */
    readonly xRequestId?: string
    
}

/**
 * NotificationsApiGenerated - object-oriented interface
 * @export
 * @class NotificationsApiGenerated
 * @extends {BaseAPI}
 */
export class NotificationsApiGenerated extends BaseAPI {
    /**
     * 
     * @summary Acknowledge a domain notification
     * @param {NotificationsApiAcknowledgeDomainNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiGenerated
     */
    public acknowledgeDomainNotification(requestParameters: NotificationsApiAcknowledgeDomainNotificationRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).acknowledgeDomainNotification(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the next domain notification
     * @param {NotificationsApiGetNextDomainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiGenerated
     */
    public getNextDomain(requestParameters: NotificationsApiGetNextDomainRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).getNextDomain(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the schema for the notification data for the specified notification type
     * @param {NotificationsApiGetSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiGenerated
     */
    public getSchema(requestParameters: NotificationsApiGetSchemaRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).getSchema(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of notification types that are opted in
     * @param {NotificationsApiListOptedInTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiGenerated
     */
    public listOptedInTypes(requestParameters: NotificationsApiListOptedInTypesRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).listOptedInTypes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Opt in to recieve notifications for the submitted notification types
     * @param {NotificationsApiOptInNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiGenerated
     */
    public optInNotifications(requestParameters: NotificationsApiOptInNotificationsRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).optInNotifications(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
